/*!
 *
 * Copyright (c) 2006-2013, Kirix Research, LLC.  All rights reserved.
 *
 * Project:  wxWebConnect Embedded Web Browser Control Library
 * Author:   Benjamin I. Williams; Peter Fritz
 * Created:  2006-10-08
 *
 */


// To generate an .h file from this .idl file, run the following command
//    xpidl -m header nsall.idl


///////////////////////////////////////////////////////////////////////////////
//  nsrootidl
///////////////////////////////////////////////////////////////////////////////


%{C++
#if 0
%}

typedef unsigned long nsresult;
typedef unsigned long nsrefcnt;
typedef unsigned long PRUint32;
typedef long PRInt32;
typedef long long PRInt64;
typedef unsigned long long PRTime;

[ref, nsid]   native nsIIDRef(nsIID);
[ref, nsid]   native nsCIDRef(nsCID);

[ref, utf8string] native AUTF8String(ignored);

[ref, astring] native AString(ignored);
[ref, cstring] native ACString(ignored);
[ref, domstring] native DOMString(ignored);

[nsid] native nsIID(nsIID);
[ref, nsid]   native nsIDRef(nsID);
//[ref, nsid] native nsIIDRef(nsIID);
[ptr, nsid]   native nsIDPtr(nsID);
[ptr, nsid]   native nsIIDPtr(nsIID);
[ptr] native nsQIResult(void);
[nsid] native nsCID(nsCID);
//[ref, nsid] native nsCIDRef(nsCID);
[ptr, nsid] native nsCIDPtr(nsCID);

[ptr] native voidPtr(void);
[ref] native voidPtrRef(void*);
[ptr] native charPtr(char);
[ref] native PRBoolRef(PRBool);


%{C++
#endif
%}


//typedef long jsword;
//typedef jsword jsval;
%{C++
struct JSObject;
typedef long jsval;
%}
native JSVal(jsval);


///////////////////////////////////////////////////////////////////////////////
//  nsISupports
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(00000000-0000-0000-c000-000000000046)]
interface nsISupports
{
    void QueryInterface(in nsIIDRef iid,
                        [iid_is(iid), retval] out nsQIResult result);
    [noscript, notxpcom] nsrefcnt AddRef();
    [noscript, notxpcom] nsrefcnt Release();
};




///////////////////////////////////////////////////////////////////////////////
//  nsISimpleEnumerator
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(d1899240-f9d2-11d2-bdd6-000064657374)]
interface nsISimpleEnumerator : nsISupports
{
    boolean hasMoreElements();
    nsISupports getNext();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIFactory
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(00000001-0000-0000-c000-000000000046)]
interface nsIFactory : nsISupports
{
    void createInstance(in nsISupports outer,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void lockFactory(in boolean lock);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIInterfaceRequestor
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(033a1470-8b2a-11d3-af88-00a024ffc08c)]
interface nsIInterfaceRequestor : nsISupports
{
    void getInterface(in nsIIDRef iid,
                      [iid_is(iid), retval] out nsQIResult result);
                      
/*
    This error is already present on http://developer.mozilla.org/xpcom/api/.
    On http://www.xulplanet.com the function reads:
    void getInterface (nsIIDRef uuid, out nsQIResult* result)
*/
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWeakReference
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(9188bc85-f92e-11d2-81ef-0060083a0bcf)]
interface nsIWeakReference : nsISupports
{
    void QueryReferent(in nsIIDRef iid,
                       [iid_is(iid), retval] out nsQIResult result);
};

[scriptable, uuid(9188bc86-f92e-11d2-81ef-0060083a0bcf)]
interface nsISupportsWeakReference : nsISupports
{
    nsIWeakReference GetWeakReference();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIFile
///////////////////////////////////////////////////////////////////////////////


interface nsISimpleEnumerator;

[scriptable, uuid(c8c0a080-0868-11d3-915f-d9d889d48e3c)]
interface nsIFile : nsISupports
{
    const unsigned long NORMAL_FILE_TYPE = 0;
    const unsigned long DIRECTORY_TYPE   = 1;
    
    void append(in AString node);
    [noscript] void appendNative(in ACString node);
    void normalize();
    void create(in PRUint32 type, in PRUint32 permissions);

    attribute AString leafName;
    [noscript] attribute ACString nativeLeafName;

    void copyTo(in nsIFile parent_dir, in AString name);
    [noscript] void copyToNative(in nsIFile parent_dir, in ACString name);
    void copyToFollowingLinks(in nsIFile parent_dir, in AString name);
    [noscript] void copyToFollowingLinksNative(in nsIFile parent_dir,
                                               in ACString name);
    void moveTo(in nsIFile parent_dir, in AString name);
    [noscript] void moveToNative(in nsIFile parent_dir, in ACString name);
    void remove(in boolean recursive);
    
    attribute unsigned long permissions;
    attribute unsigned long permissionsOfLink;
    attribute PRInt64 lastModifiedTime;
    attribute PRInt64 lastModifiedTimeOfLink;
    attribute PRInt64 fileSize;
    readonly attribute PRInt64 fileSizeOfLink;
    
    readonly attribute AString target;
    [noscript] readonly attribute ACString nativeTarget;
    
    readonly attribute AString path;
    [noscript] readonly attribute ACString nativePath;
    
    boolean exists();
    boolean isWritable();
    boolean isReadable();
    boolean isExecutable();
    boolean isHidden();
    boolean isDirectory();
    boolean isFile();
    boolean isSymlink();
    boolean isSpecial();
    void createUnique(in PRUint32 type, in PRUint32 permissions);
    nsIFile clone();
    boolean equals(in nsIFile file);
    boolean contains(in nsIFile file, in boolean recurse);
    
    readonly attribute nsIFile parent;
    readonly attribute nsISimpleEnumerator directoryEntries;
};




///////////////////////////////////////////////////////////////////////////////
//  nsILocalFile
///////////////////////////////////////////////////////////////////////////////


%{C++
struct PRFileDesc;
struct PRLibrary;
%}

[ptr] native PRFileDescStar(PRFileDesc);
[ptr] native PRLibraryStar(PRLibrary);
[ptr] native FILEStar(FILE);


[scriptable, uuid(aa610f20-a889-11d3-8c81-000064657374)]
interface nsILocalFile : nsIFile
{
    void initWithPath(in AString file_path);
    [noscript] void initWithNativePath(in ACString file_path);
    void initWithFile(in nsILocalFile file);
    
    attribute boolean followLinks;

    [noscript] PRFileDescStar openNSPRFileDesc(in long flags, in long mode);
    [noscript] FILEStar openANSIFileDesc(in string mode);
    [noscript] PRLibraryStar load();
    void appendRelativePath(in AString rel_path);
    [noscript] void appendRelativeNativePath(in ACString rel_path);
    
    attribute ACString persistentDescriptor;
    
    void reveal();
    void launch();
    
    ACString getRelativeDescriptor(in nsILocalFile from_file);
    void setRelativeDescriptor(in nsILocalFile from_file, in ACString rel_desc);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIBadCertListener
///////////////////////////////////////////////////////////////////////////////


interface nsIInterfaceRequestor;
interface nsIInterfaceRequestor;


[scriptable, uuid(f0980f60-ee3d-11d4-998b-00b0d02354a0)]
interface nsIX509Cert : nsISupports
{
    // to be filled out later
};


[scriptable, uuid(cfede939-def1-49be-81ed-d401b3a07d1c)]
interface nsISSLStatus : nsISupports
{
    readonly attribute nsIX509Cert serverCert;
    readonly attribute string cipherName;
    readonly attribute unsigned long keyLength;
    readonly attribute unsigned long secretKeyLength;
    readonly attribute boolean isDomainMismatch;
    readonly attribute boolean isNotValidAtThisTime;
    readonly attribute boolean isUntrusted;
};



[scriptable, object, uuid(86960956-edb0-11d4-998b-00b0d02354a0)]
interface nsIBadCertListener : nsISupports
{
    const short UNINIT_ADD_FLAG = -1;
    const short ADD_TRUSTED_FOR_SESSION = 1;
    const short ADD_TRUSTED_PERMANENTLY = 2;

    boolean confirmUnknownIssuer(in nsIInterfaceRequestor socketInfo, in nsIX509Cert cert, out short certAddType);
    boolean confirmMismatchDomain(in nsIInterfaceRequestor socketInfo, in AUTF8String targetURL, in nsIX509Cert cert);
    boolean confirmCertExpired(in nsIInterfaceRequestor socketInfo, in nsIX509Cert cert);
    void notifyCrlNextupdate(in nsIInterfaceRequestor socketInfo, in AUTF8String targetURL, in nsIX509Cert cert);
};



[scriptable, uuid(2c3d268c-ad82-49f3-99aa-e9ffddd7a0dc)]
interface nsIBadCertListener2 : nsISupports
{
    boolean notifyCertProblem(in nsIInterfaceRequestor socket_info, 
                              in nsISSLStatus status,
                              in AUTF8String target_site);
};


[scriptable, uuid(a5ae8b05-a76e-408f-b0ba-02a831265749)]
interface nsIRecentBadCertsService : nsISupports
{
    nsISSLStatus getRecentBadCert(in AString host_name_with_port);
    
    void addBadCert(in AString host_name_with_port,
                    in nsISSLStatus status);
};



[scriptable, uuid(31738d2a-77d3-4359-84c9-4be2f38fb8c5)]
interface nsICertOverrideService : nsISupports
{
    const short ERROR_UNTRUSTED = 1;
    const short ERROR_MISMATCH = 2;
    const short ERROR_TIME = 4;

    void rememberValidityOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            in nsIX509Cert cert,
                            in PRUint32 override_bits,
                            in boolean temporary);

    boolean hasMatchingOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            in nsIX509Cert cert,
                            out PRUint32 override_bits,
                            out boolean is_temporary);

    boolean getValidityOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            out ACString hash_alg,
                            out ACString fingerprint,
                            out PRUint32 override_bits,
                            out boolean is_temporary);

    void clearValidityOverride(
                            in ACString host_name,
                            in PRInt32 port);

    void getAllOverrideHostsWithPorts(
                            out PRUint32 count, 
                            [array, size_is(count)] out wstring hosts_with_ports_array);

    PRUint32 isCertUsedForOverrides(
                            in nsIX509Cert cert,
                            in boolean check_temporaries,
                            in boolean check_permanents);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIBaseWindow
///////////////////////////////////////////////////////////////////////////////


typedef voidPtr nativeWindow;
[ptr] native nsIWidget(nsIWidget);

%{ C++
    class nsIWidget;
%}

[scriptable, uuid(046bc8a0-8015-11d3-af70-00a024ffc08c)]
interface nsIBaseWindow : nsISupports
{
    [noscript] void initWindow(in nativeWindow parentNativeWindow,
                               in nsIWidget parentWidget,
                               in long x,
                               in long y,
                               in long cx,
                               in long cy);
    void create();
    void destroy();

    void setPosition(in long x, in long y);
    void getPosition(out long x, out long y);

    void setSize(in long cx, in long cy, in boolean fRepaint);
    void getSize(out long cx, out long cy);

    void setPositionAndSize(in long x,
                            in long y,
                            in long cx,
                            in long cy, 
                            in boolean repaint);
        
    void getPositionAndSize(out long x,
                            out long y,
                            out long cx,
                            out long cy);
    
    void repaint(in boolean force);

    [noscript] attribute nsIWidget parentWidget;
    attribute nativeWindow parentNativeWindow;
    attribute boolean visibility;
    attribute boolean enabled;
    attribute boolean blurSuppression;
    [noscript] readonly attribute nsIWidget mainWidget;
    
    void setFocus();

    attribute wstring title;
};




///////////////////////////////////////////////////////////////////////////////
//  nsICacheService
///////////////////////////////////////////////////////////////////////////////


typedef long nsCacheStoragePolicy;
interface nsICacheSession;
interface nsICacheVisitor;
interface nsIEventTarget;

[scriptable, uuid(14dbe1e9-f3bc-45af-92f4-2c574fcd4e39)]
interface nsICacheService : nsISupports
{
    /**
     * Create a cache session
     *
     * A cache session represents a client's access into the cache.  The cache
     * session is not "owned" by the cache service.  Hence, it is possible to
     * create duplicate cache sessions.  Entries created by a cache session
     * are invisible to other cache sessions, unless the cache sessions are
     * equivalent.
     *
     * @param clientID - Specifies the name of the client using the cache.
     * @param storagePolicy - Limits the storage policy for all entries
     *   accessed via the returned session.  As a result, devices excluded
     *   by the storage policy will not be searched when opening entries
     *   from the returned session.
     * @param streamBased - Indicates whether or not the data being cached
     *   can be represented as a stream.  The storagePolicy must be 
     *   consistent with the value of this field.  For example, a non-stream-
     *   based cache entry can only have a storage policy of STORE_IN_MEMORY.
     * @return new cache session.
     */
    nsICacheSession createSession(in string                 clientID,
                                  in nsCacheStoragePolicy   storagePolicy,
                                  in boolean                streamBased);

    /**
     * Visit entries stored in the cache.  Used to implement about:cache.
     */
    void visitEntries(in nsICacheVisitor visitor);

    /**
     * Evicts all entries in all devices implied by the storage policy.
     *
     * @note This function may evict some items but will throw if it fails to evict
     *       everything.
     */
    void evictEntries(in nsCacheStoragePolicy  storagePolicy);

    /**
     * Event target which is used for I/O operations
     */
    readonly attribute nsIEventTarget cacheIOTarget;
};




///////////////////////////////////////////////////////////////////////////////
//  nsICancelable
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(d94ac0a0-bb18-46b8-844e-84159064b0bd)]
interface nsICancelable : nsISupports
{
    void cancel(in nsresult reason);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIRequest
///////////////////////////////////////////////////////////////////////////////


interface nsILoadGroup;
typedef unsigned long nsLoadFlags;


[scriptable, uuid(ef6bfbd2-fd46-48d8-96b7-9f8f0fd387fe)]
interface nsIRequest : nsISupports
{
    const unsigned long LOAD_NORMAL = 0;
    const unsigned long LOAD_BACKGROUND = 1;
    const unsigned long INHIBIT_CACHING = 128;
    const unsigned long INHIBIT_PERSISTENT_CACHING = 256;
    const unsigned long LOAD_BYPASS_CACHE = 512;
    const unsigned long LOAD_FROM_CACHE = 1024;
    const unsigned long VALIDATE_ALWAYS = 2048;
    const unsigned long VALIDATE_NEVER = 4096;
    const unsigned long VALIDATE_ONCE_PER_SESSION = 8192;

    readonly attribute AUTF8String name;
    
    boolean isPending();
    
    readonly attribute nsresult status;
    
    void cancel(in nsresult status);
    void suspend();
    void resume();
    
    attribute nsILoadGroup loadGroup;
    attribute nsLoadFlags loadFlags;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIURI
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(395fe045-7d18-4adb-a3fd-af98c8a1af11)]
interface nsIURI : nsISupports
{
    /************************************************************************
     * The URI is broken down into the following principal components:
     */

    /**
     * Returns a string representation of the URI. Setting the spec causes
     * the new spec to be parsed per the rules for the scheme the URI
     * currently has.  In particular, setting the spec to a URI string with a
     * different scheme will generally produce incorrect results; no one
     * outside of a protocol handler implementation should be doing that.  If
     * the URI stores information from the nsIIOService.newURI call used to
     * create it other than just the parsed string, then behavior of this
     * information on setting the spec attribute is undefined.
     *
     * Some characters may be escaped.
     */
    attribute AUTF8String spec;

    /**
     * The prePath (eg. scheme://user:password@host:port) returns the string
     * before the path.  This is useful for authentication or managing sessions.
     *
     * Some characters may be escaped.
     */
    readonly attribute AUTF8String prePath;

    /**
     * The Scheme is the protocol to which this URI refers.  The scheme is
     * restricted to the US-ASCII charset per RFC2396.  Setting this is
     * highly discouraged outside of a protocol handler implementation, since
     * that will generally lead to incorrect results.
     */
    attribute ACString scheme;

    /**
     * The username:password (or username only if value doesn't contain a ':')
     *
     * Some characters may be escaped.
     */
    attribute AUTF8String userPass;

    /**
     * The optional username and password, assuming the preHost consists of
     * username:password.
     *
     * Some characters may be escaped.
     */
    attribute AUTF8String username;
    attribute AUTF8String password;

    /**
     * The host:port (or simply the host, if port == -1).
     *
     * Characters are NOT escaped.
     */
    attribute AUTF8String hostPort;

    /**
     * The host is the internet domain name to which this URI refers.  It could
     * be an IPv4 (or IPv6) address literal.  If supported, it could be a
     * non-ASCII internationalized domain name.
     *
     * Characters are NOT escaped.
     */
    attribute AUTF8String host;

    /**
     * A port value of -1 corresponds to the protocol's default port (eg. -1
     * implies port 80 for http URIs).
     */
    attribute long port;

    /**
     * The path, typically including at least a leading '/' (but may also be
     * empty, depending on the protocol).
     *
     * Some characters may be escaped.
     */
    attribute AUTF8String path;


    /************************************************************************
     * An URI supports the following methods:
     */

    /**
     * URI equivalence test (not a strict string comparison).
     *
     * eg. http://foo.com:80/ == http://foo.com/
     */
    boolean equals(in nsIURI other);

    /**
     * An optimization to do scheme checks without requiring the users of nsIURI
     * to GetScheme, thereby saving extra allocating and freeing. Returns true if
     * the schemes match (case ignored).
     */
    boolean schemeIs(in string scheme);

    /**
     * Clones the current URI.
     */
    nsIURI clone();

    /**
     * This method resolves a relative string into an absolute URI string,
     * using this URI as the base. 
     *
     * NOTE: some implementations may have no concept of a relative URI.
     */
    AUTF8String resolve(in AUTF8String relativePath);


    /************************************************************************
     * Additional attributes:
     */

    /**
     * The URI spec with an ASCII compatible encoding.  Host portion follows
     * the IDNA draft spec.  Other parts are URL-escaped per the rules of
     * RFC2396.  The result is strictly ASCII.
     */
    readonly attribute ACString asciiSpec;

    /**
     * The URI host with an ASCII compatible encoding.  Follows the IDNA
     * draft spec for converting internationalized domain names (UTF-8) to
     * ASCII for compatibility with existing internet infrasture.
     */
    readonly attribute ACString asciiHost;

    /**
     * The charset of the document from which this URI originated.  An empty
     * value implies UTF-8.
     *
     * If this value is something other than UTF-8 then the URI components
     * (e.g., spec, prePath, username, etc.) will all be fully URL-escaped.
     * Otherwise, the URI components may contain unescaped multibyte UTF-8
     * characters.
     */
    readonly attribute ACString originCharset;

    /************************************************************************
     * Additional attribute & methods added for .ref support:
     */

    /**
     * Returns the reference portion (the part after the "#") of the URI.
     * If there isn't one, an empty string is returned.
     *
     * Some characters may be escaped.
     */
    attribute AUTF8String ref;

    /**
     * URI equivalence test (not a strict string comparison), ignoring
     * the value of the .ref member.
     *
     * eg. http://foo.com/# == http://foo.com/
     *     http://foo.com/#aaa == http://foo.com/#bbb
     */
    boolean equalsExceptRef(in nsIURI other);

    /**
     * Clones the current URI, clearing the 'ref' attribute in the clone.
     */
    nsIURI cloneIgnoringRef();

    /**
     * returns a string for the current URI with the ref element cleared.
     */
   readonly attribute AUTF8String specIgnoringRef;

    /**
     * Returns if there is a reference portion (the part after the "#") of the URI.
     */
   readonly attribute boolean hasRef;
};


///////////////////////////////////////////////////////////////////////////////
//  nsIURIFixup
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(773081ac-9f81-4bdb-9e7a-5e87b4361f09)]
interface nsIURIFixup : nsISupports
{
    const unsigned long FIXUP_FLAG_NONE = 0;
    const unsigned long FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP = 1;
    const unsigned long FIXUP_FLAGS_MAKE_ALTERNATE_URI = 2;

    nsIURI createExposableURI(in nsIURI uri);
    nsIURI createFixupURI(in AUTF8String aURIText, in unsigned long fixup_flags);
    nsIURI keywordToURI(in AUTF8String keyword);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIChannel
///////////////////////////////////////////////////////////////////////////////

interface nsIInterfaceRequestor;
interface nsIInputStream;
interface nsIStreamListener;

[scriptable, uuid(06f6ada3-7729-4e72-8d3f-bf8ba630ff9b)]
interface nsIChannel : nsIRequest
{
    const unsigned long LOAD_DOCUMENT_URI = 65536;
    const unsigned long LOAD_RETARGETED_DOCUMENT_URI = 131072;
    const unsigned long LOAD_REPLACE = 262144;
    const unsigned long LOAD_INITIAL_DOCUMENT_URI = 524288;
    const unsigned long LOAD_TARGETED = 1048576;

    attribute nsIURI originalURI;
    readonly attribute nsIURI URI;
    attribute nsISupports owner;
    attribute nsIInterfaceRequestor notificationCallbacks;
    readonly attribute nsISupports securityInfo;
    attribute ACString contentType;
    attribute ACString contentCharset;
    attribute long contentLength;


    nsIInputStream open();
    void asyncOpen(in nsIStreamListener listener, in nsISupports xcontext);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIClipboardCommands
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(b8100c90-73be-11d2-92a5-00105a1b0d64)]
interface nsIClipboardCommands : nsISupports
{
    boolean canCutSelection();
    boolean canCopySelection();
    boolean canCopyLinkLocation();
    boolean canCopyImageLocation();
    boolean canCopyImageContents();
    boolean canPaste();
    void cutSelection();
    void copySelection();
    void copyLinkLocation();
    void copyImageLocation();
    void copyImageContents();
    void paste();
    void selectAll();
    void selectNone();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIComponentManager
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(1d940426-5fe5-42c3-84ae-a300f2d9ebd5)]
interface nsIComponentManager : nsISupports
{    
    /**
     * getClassObject
     *
     * Returns the factory object that can be used to create instances of
     * CID aClass
     *
     * @param aClass The classid of the factory that is being requested
     */
    void getClassObject(in nsCIDRef aClass,
                        in nsIIDRef aIID,
                        [iid_is(aIID),retval] out nsQIResult result);

    /**
     * getClassObjectByContractID
     *
     * Returns the factory object that can be used to create instances of
     * CID aClass
     *
     * @param aClass The classid of the factory that is being requested
     */
    void getClassObjectByContractID(in string aContractID,
                                    in nsIIDRef aIID,
                                    [iid_is(aIID),retval] out nsQIResult result);


   /**
     * createInstance
     *
     * Create an instance of the CID aClass and return the interface aIID.
     *
     * @param aClass : ClassID of object instance requested
     * @param aDelegate : Used for aggregation
     * @param aIID : IID of interface requested
     */
    void createInstance(in nsCIDRef aClass, 
                        in nsISupports aDelegate,
                        in nsIIDRef aIID, 
                        [iid_is(aIID),retval] out nsQIResult result);

    /**
     * createInstanceByContractID
     *
     * Create an instance of the CID that implements aContractID and return the
     * interface aIID. 
     *
     * @param aContractID : aContractID of object instance requested
     * @param aDelegate : Used for aggregation
     * @param aIID : IID of interface requested
     */
    void createInstanceByContractID(in string aContractID,
                                    in nsISupports aDelegate,
                                    in nsIIDRef aIID, 
                                    [iid_is(aIID),retval] out nsQIResult result);

    /**
     * addBootstrappedManifestLocation
     *
     * Adds a bootstrapped manifest location on runtime.
     *
     * @param aLocation : A directory where chrome.manifest resides,
     *                    or an XPI with it on the root.
     */
    void addBootstrappedManifestLocation(in nsILocalFile aLocation);

    /**
     * removeBootstrappedManifestLocation
     *
     * Removes a bootstrapped manifest location on runtime.
     *
     * @param aLocation : A directory where chrome.manifest resides,
     *                    or an XPI with it on the root.
     */
    void removeBootstrappedManifestLocation(in nsILocalFile aLocation);

};




///////////////////////////////////////////////////////////////////////////////
//  nsIComponentRegistrar
///////////////////////////////////////////////////////////////////////////////


interface nsIFactory;
interface nsISimpleEnumerator;

[scriptable, uuid(2417cbfe-65ad-48a6-b4b6-eb84db174392)]
interface nsIComponentRegistrar : nsISupports
{
    void autoRegister(in nsIFile spec);
    void autoUnregister(in nsIFile spec);
    
    void registerFactory(in nsCIDRef class_id,
                         in string class_name,
                         in string contract_id,
                         in nsIFactory factory);
                         
    void unregisterFactory(
                         in nsCIDRef class_id,
                         in nsIFactory factory);
                         
    void registerFactoryLocation(
                         in nsCIDRef class_id,
                         in string class_name,
                         in string contract_id,
                         in nsIFile file,
                         in string loader_str,
                         in string type);
                         
    void unregisterFactoryLocation(
                         in nsCIDRef class_id,
                         in nsIFile file);
                         
    boolean isCIDRegistered(in nsCIDRef class_id);
    boolean isContractIDRegistered(in string contract_id);
    nsISimpleEnumerator enumerateCIDs();
    nsISimpleEnumerator enumerateContractIDs();
    string CIDToContractID(in nsCIDRef class_id);
    nsCIDPtr contractIDToCID(in string contract_id);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIContextMenuListener2
///////////////////////////////////////////////////////////////////////////////


interface nsIContextMenuInfo;
interface nsIDOMEvent;
interface nsIDOMNode;
interface imgIContainer;


[scriptable, uuid(7fb719b3-d804-4964-9596-77cf924ee314)]
interface nsIContextMenuListener2 : nsISupports
{
    void onShowContextMenu(in unsigned long context_flags,
                           in nsIContextMenuInfo utils);
};


 
[scriptable, uuid(2f977d56-5485-11d4-87e2-0010a4e75ef2)]
interface nsIContextMenuInfo : nsISupports
{
    readonly attribute nsIDOMEvent mouseEvent;
    readonly attribute nsIDOMNode targetNode;
    readonly attribute AString associatedLink;
    readonly attribute imgIContainer imageContainer;
    readonly attribute nsIURI imageSrc;
    readonly attribute imgIContainer backgroundImageContainer;
    readonly attribute nsIURI backgroundImageSrc;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDirectoryService
///////////////////////////////////////////////////////////////////////////////


interface nsISimpleEnumerator;


[scriptable, uuid(bbf8cab0-d43a-11d3-8cc2-00609792278c)]
interface nsIDirectoryServiceProvider : nsISupports
{
    nsIFile getFile(in string property, out boolean persistent);
};


[scriptable, uuid(2f977d4b-5485-11d4-87e2-0010a4e75ef2)]
interface nsIDirectoryServiceProvider2 : nsIDirectoryServiceProvider
{
    nsISimpleEnumerator getFiles(in string property);
};


[scriptable, uuid(57a66a60-d43a-11d3-8cc2-00609792278c)]
interface nsIDirectoryService : nsISupports
{
    void init();
    void registerProvider(in nsIDirectoryServiceProvider provider);
    void unregisterProvider(in nsIDirectoryServiceProvider provider);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDocShellTreeItem
///////////////////////////////////////////////////////////////////////////////


interface nsIDocShellTreeOwner;
interface nsIDocShellTreeItem;


[scriptable, uuid(37f1ab73-f224-44b1-82f0-d2834ab1cec0)]
interface nsIDocShellTreeNode : nsISupports
{
    readonly attribute long childCount;
    void addChild(in nsIDocShellTreeItem child);
    void removeChild(in nsIDocShellTreeItem child);
    nsIDocShellTreeItem getChildAt(in long index);
    nsIDocShellTreeItem findChildWithName(in wstring name,
                                          in boolean recurse,
                                          in boolean same_type,
                                          in nsIDocShellTreeItem requestor,
                                          in nsIDocShellTreeItem original_requestor);
};


[scriptable, uuid(09b54ec1-d98a-49a9-bc95-3219e8b55089)]
interface nsIDocShellTreeItem : nsIDocShellTreeNode
{
    attribute wstring name;

    boolean nameEquals(in wstring name);

    const long typeChrome = 0;
    const long typeContent = 1;
    const long typeContentWrapper = 2;
    const long typeChromeWrapper = 3;
    const long typeAll = 2147483647;

    attribute long itemType;

    readonly attribute nsIDocShellTreeItem parent;
    readonly attribute nsIDocShellTreeItem sameTypeParent;
    readonly attribute nsIDocShellTreeItem rootTreeItem;
    readonly attribute nsIDocShellTreeItem sameTypeRootTreeItem;

    nsIDocShellTreeItem findItemWithName(in wstring name,
                                         in nsISupports requestor,
                                         in nsIDocShellTreeItem original_requestor);
                                         
    readonly attribute nsIDocShellTreeOwner treeOwner;

    [noscript] void setTreeOwner(in nsIDocShellTreeOwner tree_owner);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNode
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNodeList;
interface nsIDOMNamedNodeMap;
interface nsIDOMDocument;
interface nsIVariant;
interface nsIDOMUserDataHandler;
interface nsIDOMElement;
interface DOMException;

[scriptable, uuid(c8ac3f81-63e1-4c31-8543-70a656642789)]
interface nsIDOMNode : nsISupports
{
    const unsigned short ELEMENT_NODE = 1;
    const unsigned short ATTRIBUTE_NODE = 2;
    const unsigned short TEXT_NODE = 3;
    const unsigned short CDATA_SECTION_NODE = 4;
    const unsigned short ENTITY_REFERENCE_NODE = 5;
    const unsigned short ENTITY_NODE = 6;
    const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
    const unsigned short COMMENT_NODE = 8;
    const unsigned short DOCUMENT_NODE = 9;
    const unsigned short DOCUMENT_TYPE_NODE = 10;
    const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
    const unsigned short NOTATION_NODE = 12;

    readonly attribute DOMString nodeName;
    attribute DOMString nodeValue;
    readonly attribute unsigned short nodeType;
    readonly attribute nsIDOMNode parentNode;
    readonly attribute nsIDOMElement parentElement;
    readonly attribute nsIDOMNodeList childNodes;
    readonly attribute nsIDOMNode firstChild;
    readonly attribute nsIDOMNode lastChild;
    readonly attribute nsIDOMNode previousSibling;
    readonly attribute nsIDOMNode nextSibling;
    readonly attribute nsIDOMNamedNodeMap attributes;
    readonly attribute nsIDOMDocument ownerDocument;
           
    nsIDOMNode insertBefore(in nsIDOMNode new_child, in nsIDOMNode ref_child) raises(DOMException);
    nsIDOMNode replaceChild(in nsIDOMNode new_child, in nsIDOMNode old_child) raises(DOMException);
    nsIDOMNode removeChild(in nsIDOMNode old_child)  raises(DOMException);
    nsIDOMNode appendChild(in nsIDOMNode new_child) raises(DOMException);
    boolean hasChildNodes();
    nsIDOMNode cloneNode(in boolean deep);
    void normalize();
    boolean isSupported(in DOMString feature, in DOMString xversion);
    
    readonly attribute DOMString namespaceURI;
    readonly attribute DOMString prefix;
    readonly attribute DOMString localName;
    
    boolean hasAttributes();
    
    [binaryname(DOMBaseURI)] readonly attribute DOMString baseURI;

    const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short DOCUMENT_POSITION_PRECEDING    = 0x02;
    const unsigned short DOCUMENT_POSITION_FOLLOWING    = 0x04;
    const unsigned short DOCUMENT_POSITION_CONTAINS     = 0x08;
    const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

    unsigned short compareDocumentPosition(in nsIDOMNode other)
                                raises(DOMException);

    attribute DOMString textContent;

    boolean isSameNode(in nsIDOMNode other);
    DOMString lookupPrefix(in DOMString namespace_uri);
    boolean isDefaultNamespace(in DOMString namespace_uri);
    DOMString lookupNamespaceURI(in DOMString prefix);
    boolean isEqualNode(in nsIDOMNode arg);

    nsIVariant setUserData(in DOMString key, 
                           in nsIVariant data, 
                           in nsIDOMUserDataHandler handler);

    nsIVariant getUserData(in DOMString key);
    boolean contains(in nsIDOMNode other);
};







///////////////////////////////////////////////////////////////////////////////
//  nsIDOM3Node
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;
interface DOMException;
interface nsIVariant;
interface nsIDOMUserDataHandler;

[scriptable, uuid(29fb2a18-1dd2-11b2-8dd9-a6fd5d5ad12f)]
interface nsIDOM3Node : nsISupports
{
    const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
    const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
    const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
    const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    
    readonly attribute DOMString baseURI;

    unsigned short compareDocumentPosition(in nsIDOMNode other) raises(DOMException);

    attribute DOMString textContent;

    boolean isSameNode(in nsIDOMNode other);
    DOMString lookupPrefix(in DOMString namespaceURI);
    boolean isDefaultNamespace(in DOMString namespaceURI);
    DOMString lookupNamespaceURI(in DOMString prefix);
    boolean isEqualNode(in nsIDOMNode arg);
    nsISupports getFeature(in DOMString feature, in DOMString xversion);
    nsIVariant setUserData(in DOMString key, in nsIVariant data, in nsIDOMUserDataHandler handler);
    nsIVariant getUserData(in DOMString key);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOM3Document
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMDOMConfiguration;

[scriptable, uuid(2e0e9ea1-72ab-4d9e-bdeb-ca64e1abeba4)]
interface nsIDOM3Document : nsIDOM3Node
{
    readonly attribute DOMString inputEncoding;
    readonly attribute DOMString xmlEncoding;
    attribute boolean xmlStandalone;
    attribute DOMString xmlVersion;
    attribute boolean strictErrorChecking;
    attribute DOMString documentURI;
    nsIDOMNode adoptNode(in nsIDOMNode xsource) raises(DOMException);
    readonly attribute nsIDOMDOMConfiguration domConfig;
    void normalizeDocument();
    nsIDOMNode renameNode(in nsIDOMNode node, in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMAttr
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMElement;

[scriptable, uuid(03da4bc9-1b9a-41dc-a1a4-32414d48d704)]
interface nsIDOMAttr : nsIDOMNode
{
    readonly attribute DOMString name;
    readonly attribute boolean specified;
    attribute DOMString value;
    readonly attribute nsIDOMElement ownerElement;
    readonly attribute boolean isId;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAttr;
interface DOMException;


[scriptable, uuid(56aaaf03-f8f1-4c06-9cb5-f3e33a39e5c3)]
interface nsIDOMElement : nsIDOMNode
{
    readonly attribute DOMString tagName;

    DOMString getAttribute(in DOMString name);

    void setAttribute(in DOMString name,
                      in DOMString value) raises(DOMException);

    void removeAttribute(in DOMString name) raises(DOMException);

    nsIDOMAttr getAttributeNode(in DOMString name);
    nsIDOMAttr setAttributeNode(in nsIDOMAttr new_attr) raises(DOMException);

    nsIDOMAttr removeAttributeNode(in nsIDOMAttr old_attr) raises(DOMException);
 
    nsIDOMNodeList getElementsByTagName(in DOMString name);

    DOMString getAttributeNS(in DOMString namespace_uri,
                             in DOMString local_name);

    void setAttributeNS(in DOMString namespace_uri,
                        in DOMString qualified_name,
                        in DOMString value) raises(DOMException);
      
    void removeAttributeNS(in DOMString namespace_uri,
                           in DOMString local_name) raises(DOMException);

    nsIDOMAttr getAttributeNodeNS(in DOMString namespace_uri,
                                  in DOMString local_name);
         
    nsIDOMAttr setAttributeNodeNS(in nsIDOMAttr newAttr) raises(DOMException);
    
    nsIDOMNodeList getElementsByTagNameNS(in DOMString namespace_uri,
                                          in DOMString local_name);
               
    boolean hasAttribute(in DOMString name);

    boolean hasAttributeNS(in DOMString namespace_uri,
                           in DOMString local_name);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMCharacterData
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(cb75c251-afc7-444f-b2d6-b9635555f3ed)]
interface nsIDOMCharacterData : nsIDOMNode
{
    attribute DOMString data;
    readonly attribute unsigned long length;
    
    DOMString substringData(in unsigned long offset,
                            in unsigned long count)
                            raises(DOMException);
                            
    void appendData(in DOMString arg)
                    raises(DOMException);
                    
    void insertData(in unsigned long offset,
                    in DOMString arg)
                    raises(DOMException);
                    
    void deleteData(in unsigned long offset,
                    in unsigned long count)
                    raises(DOMException);
                    
    void replaceData(in unsigned long offset,
                     in unsigned long count,
                     in DOMString arg)
                     raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMDocument
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMText;
interface nsIDOMDocumentType;
interface nsIDOMDOMImplementation;
interface nsIDOMElement;
interface nsIDOMDocumentFragment;
interface nsIDOMComment;
interface nsIDOMCDATASection;
interface nsIDOMProcessingInstruction;
interface nsIDOMAttr;
interface nsIDOMRange;
interface nsIDOMNodeIterator;
interface nsIDOMTreeWalker;
interface nsIDOMNodeFilter;
interface nsIDOMWindow;
interface nsIDOMLocation;
interface nsIDOMStyleSheetList;
interface nsIDOMDOMStringList;
interface nsIDOMHTMLElement;
interface nsIDOMEntityReference;


[scriptable, uuid(6cba4f7e-7e71-427d-b914-44517ae1e45b)]
interface nsIDOMDocument : nsIDOMNode
{
    readonly attribute nsIDOMDocumentType doctype;
    readonly attribute nsIDOMDOMImplementation implementation;
    readonly attribute nsIDOMElement documentElement;
  
    nsIDOMElement createElement(in DOMString tagName) raises(DOMException);
    nsIDOMDocumentFragment createDocumentFragment();
    nsIDOMText createTextNode(in DOMString data);
    nsIDOMComment createComment(in DOMString data);
    nsIDOMCDATASection createCDATASection(in DOMString data) raises(DOMException);
    nsIDOMProcessingInstruction createProcessingInstruction(in DOMString target, in DOMString data) raises(DOMException);
    nsIDOMAttr createAttribute(in DOMString name) raises(DOMException);
    nsIDOMNodeList getElementsByTagName(in DOMString tagname);
    nsIDOMNode importNode(in nsIDOMNode importedNode, in boolean deep) raises(DOMException);
    nsIDOMElement createElementNS(in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
    nsIDOMAttr createAttributeNS(in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
    nsIDOMNodeList getElementsByTagNameNS(in DOMString namespaceURI, in DOMString localName);
    nsIDOMElement getElementById(in DOMString elementId);
    
    readonly attribute DOMString inputEncoding;
    readonly attribute DOMString xmlEncoding;
    attribute boolean xmlStandalone;
    attribute DOMString xmlVersion;
    attribute DOMString documentURI;

    nsIDOMNode adoptNode(in nsIDOMNode source) raises(DOMException);
    nsIDOMRange createRange();

    nsIDOMNodeIterator createNodeIterator(in nsIDOMNode root,
                            in unsigned long whatToShow,
                            in nsIDOMNodeFilter filter,
                            in boolean entityReferenceExpansion)
                            raises(DOMException);

    nsIDOMTreeWalker createTreeWalker(in nsIDOMNode root,
                            in unsigned long whatToShow,
                            in nsIDOMNodeFilter filter,
                            in boolean entityReferenceExpansion)
                            raises(DOMException);

    nsIDOMEvent createEvent(in DOMString eventType)
    raises(DOMException);



    readonly attribute nsIDOMWindow defaultView;
    readonly attribute DOMString characterSet;
    attribute DOMString dir;
    readonly attribute nsIDOMLocation location;
    attribute DOMString title;
    readonly attribute DOMString readyState;
    readonly attribute DOMString lastModified;
    readonly attribute DOMString referrer;
    
    boolean hasFocus();

    readonly attribute nsIDOMElement activeElement;
    
    nsIDOMNodeList getElementsByClassName(in DOMString classes);

    readonly attribute nsIDOMStyleSheetList styleSheets;
    readonly attribute DOMString preferredStyleSheetSet;
    attribute DOMString selectedStyleSheetSet;
    readonly attribute DOMString lastStyleSheetSet;
    readonly attribute nsIDOMDOMStringList styleSheetSets;
    
    void enableStyleSheetsForSet(in DOMString name);
    nsIDOMElement elementFromPoint(in float x, in float y);

    readonly attribute DOMString contentType;
    readonly attribute boolean mozSyntheticDocument;
    readonly attribute nsIDOMElement currentScript;

    void releaseCapture();

    void mozSetImageElement(in DOMString aImageElementId,
                            in nsIDOMElement aImageElement);

    readonly attribute nsIDOMHTMLElement mozFullScreenElement;

    void mozCancelFullScreen();   

    readonly attribute boolean mozFullScreen;  
    //[implicit_jscontext]
    [noscript] attribute jsval onreadystatechange; 
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;
interface nsIDOMEventTarget;
interface DOMTimeStamp;


[scriptable, uuid(548137e8-fd2c-48c4-8635-3033f7db79e0)]
interface nsIDOMEvent : nsISupports
{
    const unsigned short CAPTURING_PHASE = 1;
    const unsigned short AT_TARGET = 2;
    const unsigned short BUBBLING_PHASE = 3;

    readonly attribute DOMString type;
    readonly attribute nsIDOMEventTarget target;
    readonly attribute nsIDOMEventTarget currentTarget;
    readonly attribute unsigned short eventPhase;
    readonly attribute boolean bubbles;
    readonly attribute boolean cancelable;
    readonly attribute DOMTimeStamp timeStamp;

    void stopPropagation();
    
    void preventDefault();
    
    void initEvent(in DOMString event_type_arg,
                   in boolean can_bubble_arg,
                   in boolean cancelable_arg);
                   
    readonly attribute boolean defaultPrevented;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEventListener
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEvent;


[scriptable, function, uuid(df31c120-ded6-11d1-bd85-00805f8ae3f4)]
interface nsIDOMEventListener : nsISupports
{
    void handleEvent(in nsIDOMEvent event);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEventTarget
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEvent;
interface nsIDOMEventListener;
interface DOMException;


[scriptable, builtinclass, uuid(1797d5a4-b12a-428d-9eef-a0e13839728c)]
interface nsIDOMEventTarget : nsISupports
{
    [optional_argc] void addEventListener(in DOMString type,
                          in nsIDOMEventListener listener,
                          [optional] in boolean use_capture,
                          [optional] in boolean wants_untrusted,
                          in char argc);

    void removeEventListener(
                          in DOMString type,
                          in nsIDOMEventListener listener,
                          [optional] in boolean use_capture);

    boolean dispatchEvent(in nsIDOMEvent evt) raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(6ecb115c-8a7b-495b-958e-2ef5d8a50244)]
interface nsIDOMHTMLElement : nsIDOMElement
{
    attribute DOMString id;
    attribute DOMString title;
    attribute DOMString lang;
    attribute DOMString dir;
    attribute DOMString className;
    
    attribute DOMString accessKey;
    readonly attribute DOMString accessKeyLabel;

    void blur();
    void focus();
    void click();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLAnchorElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(dfcf9a0b-2bc4-465b-b007-9c0e26aabc17)]
interface nsIDOMHTMLAnchorElement : nsIDOMHTMLElement
{
    attribute DOMString href;
    attribute DOMString target;
    attribute DOMString ping;
    attribute DOMString rel;
    attribute DOMString hreflang;
    attribute DOMString type;

    [Null(Stringify)] attribute DOMString text;

    attribute DOMString protocol;
    attribute DOMString host;
    attribute DOMString hostname;
    attribute DOMString port;
    attribute DOMString pathname;
    attribute DOMString search;
    attribute DOMString hash;

    attribute DOMString charset;
    attribute DOMString coords;
    attribute DOMString name;
    attribute DOMString rev;
    attribute DOMString shape;
    attribute long tabIndex;

    DOMString toString();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLInputElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;
interface nsIDOMValidityState;

[scriptable, uuid(a7740abf-dbef-4a5e-a8a8-be5809c5d851)]
interface nsIDOMHTMLButtonElement : nsIDOMHTMLElement
{
    attribute boolean autofocus;
    attribute boolean disabled;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString formAction;
    attribute DOMString formEnctype;
    attribute DOMString formMethod;
    attribute boolean formNoValidate;
    attribute DOMString formTarget;
    attribute DOMString name;
    attribute DOMString type;
    attribute DOMString value;
    attribute long tabIndex;
    readonly attribute boolean willValidate;
    readonly attribute nsIDOMValidityState validity;
    readonly attribute DOMString validationMessage;
    
    boolean checkValidity();
    void setCustomValidity(in DOMString error);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLInputElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;
interface nsIDOMFileList;
interface nsIControllers;

[scriptable, uuid(90fa1822-deca-4732-bc50-0b5393ffd129)]
interface nsIDOMHTMLInputElement : nsIDOMHTMLElement
{
    attribute DOMString accept;
    attribute DOMString alt;
    attribute DOMString autocomplete;
    attribute boolean autofocus;
    attribute boolean defaultChecked;
    attribute boolean checked;
    attribute boolean disabled;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString formAction;
    attribute DOMString formEnctype;
    attribute DOMString formMethod;
    attribute boolean formNoValidate;
    attribute DOMString formTarget;
    readonly attribute nsIDOMFileList files;
    attribute boolean indeterminate;
    readonly attribute nsIDOMHTMLElement list;
    attribute long maxLength;
    attribute boolean multiple;
    attribute DOMString name;
    attribute DOMString pattern;
    attribute DOMString placeholder;
    attribute boolean readOnly;
    attribute boolean required;
    attribute DOMString align;
    attribute unsigned long size;
    attribute DOMString src;
    attribute DOMString type;
    attribute DOMString defaultValue;
    attribute DOMString value;
    readonly attribute boolean willValidate;
    readonly attribute nsIDOMValidityState validity;
    readonly attribute DOMString validationMessage;
    
    boolean checkValidity();
    void setCustomValidity(in DOMString error);
    void select();
    
    attribute long selectionStart;
    attribute long selectionEnd;
    
    void setSelectionRange(in long selectionStart,
                           in long selectionEnd,
                           [optional] in DOMString direction);
                           
    attribute DOMString selectionDirection;
    attribute long tabIndex;
    attribute DOMString useMap;
    readonly attribute nsIControllers controllers;    
    readonly attribute long textLength;

    void mozGetFileNameArray([optional] out unsigned long aLength,
                             [array,size_is(aLength), retval] out wstring aFileNames);
                             
    void mozSetFileNameArray([array,size_is(aLength)] in wstring aFileNames,
                             in unsigned long aLength);
    
    boolean mozIsTextField(in boolean aExcludePassword);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLLinkElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(442dddcc-cdc3-4385-946d-9d6b8b4eb927)]
interface nsIDOMHTMLLinkElement : nsIDOMHTMLElement
{
    attribute boolean disabled;
    attribute DOMString charset;
    attribute DOMString href;
    attribute DOMString hreflang;
    attribute DOMString media;
    attribute DOMString rel;
    attribute DOMString rev;
    attribute DOMString target;
    attribute DOMString type;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLInputElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;


[scriptable, uuid(a36a1710-7684-4fb7-a401-ccbf442064c1)]
interface nsIDOMHTMLOptionElement : nsIDOMHTMLElement
{
    attribute boolean disabled;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString label;
    attribute boolean defaultSelected;
    attribute boolean selected;
    attribute DOMString value;
    attribute DOMString text;
    readonly attribute long index;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLParamElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(e7e2ac93-7a44-4c9d-bf4a-4b7231b6e9a8)]
interface nsIDOMHTMLParamElement : nsIDOMHTMLElement
{
    attribute DOMString name;
    attribute DOMString type;
    attribute DOMString value;
    attribute DOMString valueType;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLSelectElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;
interface nsIDOMHTMLOptionsCollection;

[scriptable, uuid(f6e68b8c-58cf-49dd-8d70-de8768ac5bac)]
interface nsIDOMHTMLSelectElement : nsIDOMHTMLElement
{
    attribute boolean autofocus;
    attribute boolean disabled;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute boolean multiple;
    attribute DOMString name;
    attribute long size;
    readonly attribute DOMString type;
    readonly attribute nsIDOMHTMLOptionsCollection options;
    attribute unsigned long length;
    
    nsIDOMNode item(in unsigned long index);
    nsIDOMNode namedItem(in DOMString name);
    
    void add(in nsIDOMHTMLElement element, 
             [optional] in nsIVariant before)
                raises(DOMException); 
    void remove(in long index);

    attribute long selectedIndex;
    attribute DOMString value;
    attribute long tabIndex;
    readonly attribute boolean willValidate;
    readonly attribute nsIDOMValidityState validity;
    readonly attribute DOMString validationMessage;
    
    boolean checkValidity();
    void setCustomValidity(in DOMString error);
    
    attribute boolean required;
};



///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLTextAreaElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;

[scriptable, uuid(3fa5ddd0-060e-4de7-835d-0c02cb3f6e79)]
interface nsIDOMHTMLTextAreaElement : nsIDOMHTMLElement
{
    attribute boolean autofocus;
    attribute unsigned long cols;
    attribute boolean disabled;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute long maxLength;
    attribute DOMString name;
    attribute DOMString placeholder;
    attribute boolean readOnly;
    attribute boolean required;
    attribute unsigned long rows;
    [Null(Stringify)] attribute DOMString wrap;
    readonly attribute DOMString type;
    attribute DOMString defaultValue;
    attribute DOMString value;
    readonly attribute long textLength;
    readonly attribute boolean willValidate;
    readonly attribute nsIDOMValidityState validity;
    readonly attribute DOMString validationMessage;
    
    boolean checkValidity();
    void setCustomValidity(in DOMString error);
    void select();
    
    attribute long selectionStart;
    attribute long selectionEnd;
    
    void setSelectionRange(in long selectionStart,
                           in long selectionEnd,
                           [optional] in DOMString direction);
    
    attribute DOMString selectionDirection;
    attribute long tabIndex;
    readonly attribute nsIControllers controllers;
};





///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNamedNodeMap
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;
interface DOMException;


[scriptable, uuid(a6cf907b-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNamedNodeMap : nsISupports
{
    nsIDOMNode getNamedItem(in DOMString name);
    nsIDOMNode setNamedItem(in nsIDOMNode arg) raises(DOMException);
    nsIDOMNode removeNamedItem(in DOMString name) raises(DOMException);
    nsIDOMNode item(in unsigned long index);
    
    readonly attribute unsigned long length;
    
    nsIDOMNode getNamedItemNS(in DOMString namespace_uri,
                              in DOMString local_name);
                                              
    nsIDOMNode setNamedItemNS(in nsIDOMNode arg)
                                      raises(DOMException);
    
    nsIDOMNode removeNamedItemNS(
                              in DOMString namespace_uri,
                              in DOMString local_name)
                                      raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNodeList
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;

[scriptable, uuid(a6cf907d-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNodeList : nsISupports
{
    nsIDOMNode item(in unsigned long index);
    readonly attribute unsigned long length;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMText
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(92b0df87-78a1-4e3b-a23c-d0c5bb2b83f9)]
interface nsIDOMText : nsIDOMCharacterData
{
    nsIDOMText splitText(in unsigned long offset)
                         raises(DOMException);
                         
    readonly attribute boolean isElementContentWhitespace;
    readonly attribute DOMString wholeText;
    nsIDOMText replaceWholeText(in DOMString content) raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMWindow
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMDocument;
interface nsIDOMBarProp;
interface nsIDOMWindowCollection;
interface nsISelection;
interface nsIDOMLocation;
interface nsIDOMHistory;
interface nsIDOMNavigator;
interface nsIDOMOfflineResourceList;
interface nsIDOMStorage;
interface nsIDOMMediaQueryList;
interface nsIDOMScreen;
interface nsIDOMCSSStyleDeclaration;
interface nsIDOMCrypto;
interface nsIDOMPkcs11;
interface nsIDOMStorageList;
interface nsIPrompt;
interface nsIControllers;
interface nsIAnimationFrameListener;
interface nsIDOMMozURLProperty;

[scriptable, uuid(3f5b2af2-604e-4253-8d25-6d3cafc13a69)]
interface nsIDOMWindow : nsISupports
{
    readonly attribute nsIDOMWindow window;
    readonly attribute nsIDOMWindow self;
    readonly attribute nsIDOMDocument document;
    
    attribute DOMString name;

    readonly attribute nsIDOMLocation location;
    readonly attribute nsIDOMHistory history;
    readonly attribute nsIDOMBarProp locationbar;
    readonly attribute nsIDOMBarProp menubar;
    readonly attribute nsIDOMBarProp personalbar;
    readonly attribute nsIDOMBarProp scrollbars;
    readonly attribute nsIDOMBarProp statusbar;
    readonly attribute nsIDOMBarProp toolbar;

    attribute DOMString status;

    void close();
    void stop();
    void focus();
    void blur();


    readonly attribute unsigned long length;
    readonly attribute nsIDOMWindow top;
    attribute nsIDOMWindow opener;
    readonly attribute nsIDOMWindow parent;
    readonly attribute nsIDOMElement frameElement;
    readonly attribute nsIDOMNavigator navigator;
    readonly attribute nsIDOMOfflineResourceList applicationCache;

    void alert(in DOMString text);
    boolean confirm(in DOMString text);

    DOMString prompt([optional] in DOMString aMessage,
                     [optional] in DOMString aInitial);

    void print();

    nsIVariant showModalDialog(in DOMString aURI,
                               [optional] in nsIVariant aArgs,
                               [optional] in DOMString aOptions);

    //[implicit_jscontext, binaryname(PostMessageMoz)]
    [noscript]
    void postMessage(in jsval message, in DOMString targetOrigin);

    DOMString atob(in DOMString aAsciiString);
    DOMString btoa(in DOMString aBase64Data);

    readonly attribute nsIDOMStorage sessionStorage;
    readonly attribute nsIDOMStorage localStorage;

    nsISelection getSelection();

    nsIDOMMediaQueryList matchMedia(in DOMString media_query_list);

    readonly attribute nsIDOMScreen screen;
    attribute long innerWidth;
    attribute long innerHeight;

    readonly attribute long scrollX;
    readonly attribute long pageXOffset;
    readonly attribute long scrollY;
    readonly attribute long pageYOffset;
    
    void scroll(in long xScroll, in long yScroll);
    void scrollTo(in long xScroll, in long yScroll);
    void scrollBy(in long xScrollDif, in long yScrollDif);

    attribute long screenX;
    attribute long screenY;
    attribute long outerWidth;
    attribute long outerHeight;


    nsIDOMCSSStyleDeclaration getComputedStyle(in nsIDOMElement elt, 
                                               [optional] in DOMString pseudoElt);
    
    [noscript] readonly attribute nsIDOMEventTarget windowRoot;

    [noscript] readonly attribute nsIDOMWindowCollection frames;


    [noscript] attribute float textZoom;

    void scrollByLines(in long numLines);
    void scrollByPages(in long numPages);

    void sizeToContent();
    
    readonly attribute nsIDOMWindow content;
    [noscript] readonly attribute nsIPrompt prompter;

    readonly attribute boolean closed;
    readonly attribute nsIDOMCrypto crypto;
    readonly attribute nsIDOMPkcs11 pkcs11;
    readonly attribute nsIControllers controllers;
    
    attribute DOMString defaultStatus;

    readonly attribute float mozInnerScreenX;
    readonly attribute float mozInnerScreenY;
    readonly attribute long scrollMaxX;
    readonly attribute long scrollMaxY;

    attribute boolean fullScreen;

    void back();
    void forward();
    void home();

    void moveTo(in long xPos, in long yPos);
    void moveBy(in long xDif, in long yDif);
    void resizeTo(in long width, in long height);
    void resizeBy(in long widthDif, in long heightDif);

    [noscript] nsIDOMWindow open(in DOMString url,
                                 in DOMString name,
                                 in DOMString options);

    [noscript] nsIDOMWindow openDialog(
                                 in DOMString url,
                                 in DOMString name,
                                 in DOMString options,
                                 in nsISupports aExtraArgument);

    void updateCommands(in DOMString action);

    boolean find([optional] in DOMString str,
                 [optional] in boolean caseSensitive,
                 [optional] in boolean backwards,
                 [optional] in boolean wrapAround,
                 [optional] in boolean wholeWord,
                 [optional] in boolean searchInFrames,
                 [optional] in boolean showDialog);

    readonly attribute unsigned long long mozPaintCount;

    void mozRequestAnimationFrame([optional] in nsIAnimationFrameListener aListener);
    readonly attribute long long mozAnimationStartTime;
    readonly attribute nsIDOMMozURLProperty URL;
    readonly attribute nsIDOMStorageList globalStorage;

/*
    [implicit_jscontext] attribute jsval onafterprint;
    [implicit_jscontext] attribute jsval onbeforeprint;
    [implicit_jscontext] attribute jsval onbeforeunload;
    [implicit_jscontext] attribute jsval onhashchange;
    [implicit_jscontext] attribute jsval onmessage;
    [implicit_jscontext] attribute jsval onoffline;
    [implicit_jscontext] attribute jsval ononline;
    [implicit_jscontext] attribute jsval onpopstate;
    [implicit_jscontext] attribute jsval onpagehide;
    [implicit_jscontext] attribute jsval onpageshow;
    [implicit_jscontext] attribute jsval onresize;
    [implicit_jscontext] attribute jsval onunload;
    [implicit_jscontext] attribute jsval ondevicemotion;
    [implicit_jscontext] attribute jsval ondeviceorientation;
    [implicit_jscontext] attribute jsval onmouseenter;
    [implicit_jscontext] attribute jsval onmouseleave;
*/
};






///////////////////////////////////////////////////////////////////////////////
//  nsIDOMUIEvent
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(4f3032d1-bdc5-4f37-bece-af8056d71c5c)]
interface nsIDOMUIEvent : nsIDOMEvent
{
    readonly attribute nsIDOMWindow view;
    readonly attribute long detail;

    void initUIEvent(in DOMString type_arg,
                     in boolean can_bubble_arg,
                     in boolean cancelable_arg,
                     in nsIDOMWindow view_arg,
                     in long detail_arg);

    const long SCROLL_PAGE_UP = -32768;
    const long SCROLL_PAGE_DOWN = 32768;

    readonly attribute long layerX;
    readonly attribute long layerY;
    readonly attribute long pageX;
    readonly attribute long  pageY;
    readonly attribute unsigned long which;
    readonly attribute nsIDOMNode rangeParent;
    readonly attribute long rangeOffset;

    attribute boolean cancelBubble;

    readonly attribute boolean isChar;
};






///////////////////////////////////////////////////////////////////////////////
//  nsIDOMMouseEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEventTarget;


[scriptable, uuid(7e6cb6e1-d3ba-4e60-a6ff-96350187a1e3)]
interface nsIDOMMouseEvent : nsIDOMUIEvent
{
    readonly attribute long screenX;
    readonly attribute long screenY;
    readonly attribute long clientX;
    readonly attribute long clientY;
    readonly attribute boolean ctrlKey;
    readonly attribute boolean shiftKey;
    readonly attribute boolean altKey;
    readonly attribute boolean metaKey;
    readonly attribute unsigned short button;
    readonly attribute nsIDOMEventTarget relatedTarget;
 
    void initMouseEvent(in DOMString type_arg,
                        in boolean can_bubble_arg,
                        in boolean cancelable_arg,
                        in nsIDOMWindow view_arg,
                        in long detail_arg,
                        in long screen_x_arg,
                        in long screen_y_arg,
                        in long client_x_arg,
                        in long client_y_arg,
                        in boolean ctrl_key_arg,
                        in boolean alt_key_arg,
                        in boolean shift_key_arg,
                        in boolean meta_key_arg,
                        in unsigned short button_arg,
                        in nsIDOMEventTarget related_target_arg);

    readonly attribute float mozPressure;

    const unsigned short MOZ_SOURCE_UNKNOWN    = 0;
    const unsigned short MOZ_SOURCE_MOUSE      = 1;
    const unsigned short MOZ_SOURCE_PEN        = 2;
    const unsigned short MOZ_SOURCE_ERASER     = 3;
    const unsigned short MOZ_SOURCE_CURSOR     = 4;
    const unsigned short MOZ_SOURCE_TOUCH      = 5;
    const unsigned short MOZ_SOURCE_KEYBOARD   = 6;

    readonly attribute unsigned short mozInputSource;

    void initNSMouseEvent(in DOMString typeArg,
                in boolean canBubbleArg,
                in boolean cancelableArg,
                in nsIDOMWindow viewArg,
                in long detailArg,
                in long screenXArg,
                in long screenYArg,
                in long clientXArg,
                in long clientYArg,
                in boolean ctrlKeyArg,
                in boolean altKeyArg,
                in boolean shiftKeyArg,
                in boolean metaKeyArg,
                in unsigned short buttonArg,
                in nsIDOMEventTarget relatedTargetArg,
                in float pressure,
                in unsigned short inputSourceArg);
};




[scriptable, uuid(ffcfb88a-d1d1-40b9-96e1-e338211d3511)]
interface nsIDOMKeyEvent : nsIDOMUIEvent
{
  const unsigned long DOM_VK_CANCEL         = 0x03;
  const unsigned long DOM_VK_HELP           = 0x06;
  const unsigned long DOM_VK_BACK_SPACE     = 0x08;
  const unsigned long DOM_VK_TAB            = 0x09;
  const unsigned long DOM_VK_CLEAR          = 0x0C;
  const unsigned long DOM_VK_RETURN         = 0x0D;
  const unsigned long DOM_VK_ENTER          = 0x0E;
  const unsigned long DOM_VK_SHIFT          = 0x10;
  const unsigned long DOM_VK_CONTROL        = 0x11;
  const unsigned long DOM_VK_ALT            = 0x12;
  const unsigned long DOM_VK_PAUSE          = 0x13;
  const unsigned long DOM_VK_CAPS_LOCK      = 0x14;
  const unsigned long DOM_VK_KANA           = 0x15;
  const unsigned long DOM_VK_HANGUL         = 0x15;
  const unsigned long DOM_VK_JUNJA          = 0x17;
  const unsigned long DOM_VK_FINAL          = 0x18;
  const unsigned long DOM_VK_HANJA          = 0x19;
  const unsigned long DOM_VK_KANJI          = 0x19;
  const unsigned long DOM_VK_ESCAPE         = 0x1B;
  const unsigned long DOM_VK_CONVERT        = 0x1C;
  const unsigned long DOM_VK_NONCONVERT     = 0x1D;
  const unsigned long DOM_VK_ACCEPT         = 0x1E;
  const unsigned long DOM_VK_MODECHANGE     = 0x1F;
  const unsigned long DOM_VK_SPACE          = 0x20;
  const unsigned long DOM_VK_PAGE_UP        = 0x21;
  const unsigned long DOM_VK_PAGE_DOWN      = 0x22;
  const unsigned long DOM_VK_END            = 0x23;
  const unsigned long DOM_VK_HOME           = 0x24;
  const unsigned long DOM_VK_LEFT           = 0x25;
  const unsigned long DOM_VK_UP             = 0x26;
  const unsigned long DOM_VK_RIGHT          = 0x27;
  const unsigned long DOM_VK_DOWN           = 0x28;
  const unsigned long DOM_VK_SELECT         = 0x29;
  const unsigned long DOM_VK_PRINT          = 0x2A;
  const unsigned long DOM_VK_EXECUTE        = 0x2B;
  const unsigned long DOM_VK_PRINTSCREEN    = 0x2C;
  const unsigned long DOM_VK_INSERT         = 0x2D;
  const unsigned long DOM_VK_DELETE         = 0x2E;

  // DOM_VK_0 - DOM_VK_9 match their ascii values
  const unsigned long DOM_VK_0              = 0x30;
  const unsigned long DOM_VK_1              = 0x31;
  const unsigned long DOM_VK_2              = 0x32;
  const unsigned long DOM_VK_3              = 0x33;
  const unsigned long DOM_VK_4              = 0x34;
  const unsigned long DOM_VK_5              = 0x35;
  const unsigned long DOM_VK_6              = 0x36;
  const unsigned long DOM_VK_7              = 0x37;
  const unsigned long DOM_VK_8              = 0x38;
  const unsigned long DOM_VK_9              = 0x39;

  const unsigned long DOM_VK_SEMICOLON      = 0x3B;
  const unsigned long DOM_VK_EQUALS         = 0x3D;

  // DOM_VK_A - DOM_VK_Z match their ascii values
  const unsigned long DOM_VK_A              = 0x41;
  const unsigned long DOM_VK_B              = 0x42;
  const unsigned long DOM_VK_C              = 0x43;
  const unsigned long DOM_VK_D              = 0x44;
  const unsigned long DOM_VK_E              = 0x45;
  const unsigned long DOM_VK_F              = 0x46;
  const unsigned long DOM_VK_G              = 0x47;
  const unsigned long DOM_VK_H              = 0x48;
  const unsigned long DOM_VK_I              = 0x49;
  const unsigned long DOM_VK_J              = 0x4A;
  const unsigned long DOM_VK_K              = 0x4B;
  const unsigned long DOM_VK_L              = 0x4C;
  const unsigned long DOM_VK_M              = 0x4D;
  const unsigned long DOM_VK_N              = 0x4E;
  const unsigned long DOM_VK_O              = 0x4F;
  const unsigned long DOM_VK_P              = 0x50;
  const unsigned long DOM_VK_Q              = 0x51;
  const unsigned long DOM_VK_R              = 0x52;
  const unsigned long DOM_VK_S              = 0x53;
  const unsigned long DOM_VK_T              = 0x54;
  const unsigned long DOM_VK_U              = 0x55;
  const unsigned long DOM_VK_V              = 0x56;
  const unsigned long DOM_VK_W              = 0x57;
  const unsigned long DOM_VK_X              = 0x58;
  const unsigned long DOM_VK_Y              = 0x59;
  const unsigned long DOM_VK_Z              = 0x5A;

  const unsigned long DOM_VK_CONTEXT_MENU   = 0x5D;
  const unsigned long DOM_VK_SLEEP          = 0x5F;

  const unsigned long DOM_VK_NUMPAD0        = 0x60;
  const unsigned long DOM_VK_NUMPAD1        = 0x61;
  const unsigned long DOM_VK_NUMPAD2        = 0x62;
  const unsigned long DOM_VK_NUMPAD3        = 0x63;
  const unsigned long DOM_VK_NUMPAD4        = 0x64;
  const unsigned long DOM_VK_NUMPAD5        = 0x65;
  const unsigned long DOM_VK_NUMPAD6        = 0x66;
  const unsigned long DOM_VK_NUMPAD7        = 0x67;
  const unsigned long DOM_VK_NUMPAD8        = 0x68;
  const unsigned long DOM_VK_NUMPAD9        = 0x69;
  const unsigned long DOM_VK_MULTIPLY       = 0x6A;
  const unsigned long DOM_VK_ADD            = 0x6B;
  const unsigned long DOM_VK_SEPARATOR      = 0x6C;
  const unsigned long DOM_VK_SUBTRACT       = 0x6D;
  const unsigned long DOM_VK_DECIMAL        = 0x6E;
  const unsigned long DOM_VK_DIVIDE         = 0x6F;
  const unsigned long DOM_VK_F1             = 0x70;
  const unsigned long DOM_VK_F2             = 0x71;
  const unsigned long DOM_VK_F3             = 0x72;
  const unsigned long DOM_VK_F4             = 0x73;
  const unsigned long DOM_VK_F5             = 0x74;
  const unsigned long DOM_VK_F6             = 0x75;
  const unsigned long DOM_VK_F7             = 0x76;
  const unsigned long DOM_VK_F8             = 0x77;
  const unsigned long DOM_VK_F9             = 0x78;
  const unsigned long DOM_VK_F10            = 0x79;
  const unsigned long DOM_VK_F11            = 0x7A;
  const unsigned long DOM_VK_F12            = 0x7B;
  const unsigned long DOM_VK_F13            = 0x7C;
  const unsigned long DOM_VK_F14            = 0x7D;
  const unsigned long DOM_VK_F15            = 0x7E;
  const unsigned long DOM_VK_F16            = 0x7F;
  const unsigned long DOM_VK_F17            = 0x80;
  const unsigned long DOM_VK_F18            = 0x81;
  const unsigned long DOM_VK_F19            = 0x82;
  const unsigned long DOM_VK_F20            = 0x83;
  const unsigned long DOM_VK_F21            = 0x84;
  const unsigned long DOM_VK_F22            = 0x85;
  const unsigned long DOM_VK_F23            = 0x86;
  const unsigned long DOM_VK_F24            = 0x87;

  const unsigned long DOM_VK_NUM_LOCK       = 0x90;
  const unsigned long DOM_VK_SCROLL_LOCK    = 0x91;

  const unsigned long DOM_VK_COMMA          = 0xBC;
  const unsigned long DOM_VK_PERIOD         = 0xBE;
  const unsigned long DOM_VK_SLASH          = 0xBF;
  const unsigned long DOM_VK_BACK_QUOTE     = 0xC0;
  const unsigned long DOM_VK_OPEN_BRACKET   = 0xDB;
  const unsigned long DOM_VK_BACK_SLASH     = 0xDC;
  const unsigned long DOM_VK_CLOSE_BRACKET  = 0xDD;
  const unsigned long DOM_VK_QUOTE          = 0xDE;

  const unsigned long DOM_VK_META           = 0xE0;

  readonly attribute unsigned long    charCode;
  readonly attribute unsigned long    keyCode;

  readonly attribute boolean          altKey;
  readonly attribute boolean          ctrlKey;
  readonly attribute boolean          shiftKey;
  readonly attribute boolean          metaKey;

  void                      initKeyEvent(in DOMString typeArg,
                                         in boolean canBubbleArg,
                                         in boolean cancelableArg,
                                         in nsIDOMWindow viewArg,
                                         in boolean ctrlKeyArg,
                                         in boolean altKeyArg,
                                         in boolean shiftKeyArg,
                                         in boolean metaKeyArg,
                                         in unsigned long keyCodeArg,
                                         in unsigned long charCodeArg);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIEmbeddingSiteWindow
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(3e5432cd-9568-4bd1-8cbe-d50aba110743)]
interface nsIEmbeddingSiteWindow : nsISupports
{
    const unsigned long DIM_FLAGS_POSITION = 1;
    const unsigned long DIM_FLAGS_SIZE_INNER = 2;
    const unsigned long DIM_FLAGS_SIZE_OUTER = 4;
    
    void setDimensions(in unsigned long flags,
                       in long x,
                       in long y,
                       in long cx,
                       in long cy);
                       
    void getDimensions(in unsigned long flags,
                       out long x,
                       out long y,
                       out long cx,
                       out long cy);
                       
    void setFocus();
    
    attribute boolean visibility;
    attribute wstring title;
    [noscript] readonly attribute voidPtr siteWindow;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIEmbeddingSiteWindow2
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(e932bf55-0a64-4beb-923a-1f32d3661044)]
interface nsIEmbeddingSiteWindow2 : nsIEmbeddingSiteWindow
{
    void blur();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIHelperAppLauncher
///////////////////////////////////////////////////////////////////////////////


interface nsIWebProgressListener2;
interface nsIMIMEInfo;


[scriptable, object, uuid(d9a19faf-497b-408c-b995-777d956b72c0)]
interface nsIHelperAppLauncher : nsICancelable
{
    readonly attribute nsIMIMEInfo MIMEInfo;
    readonly attribute nsIURI source;
    readonly attribute AString suggestedFileName;

    void saveToDisk(in nsIFile new_file_location,
                    in boolean remember_this_preference);

    void launchWithApplication(in nsIFile application,
                               in boolean remember_this_preference);

    void setWebProgressListener(in nsIWebProgressListener2 web_progress_listener);

    void closeProgressWindow();

    readonly attribute nsIFile targetFile;
    readonly attribute boolean targetFileIsExecutable;
    readonly attribute PRTime timeDownloadStarted;
    readonly attribute PRInt64 contentLength;
};



///////////////////////////////////////////////////////////////////////////////
//  nsIHelperAppLauncherDialog
///////////////////////////////////////////////////////////////////////////////


interface nsIHelperAppLauncher;
interface nsILocalFile;


[scriptable, object, uuid(f3704fdc-8ae6-4eba-a3c3-f02958ac0649)]
interface nsIHelperAppLauncherDialog : nsISupports
{
    const unsigned long REASON_CANTHANDLE = 0;
    const unsigned long REASON_SERVERREQUEST = 1;
    const unsigned long REASON_TYPESNIFFED = 2;
    
    void show(in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in unsigned long reason);

    nsILocalFile promptForSaveToFile(
              in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in wstring defaultFile,
              in wstring suggestedFileExtension,
              in boolean force_prompt);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIInputStream
///////////////////////////////////////////////////////////////////////////////


%{C++

typedef NS_CALLBACK(nsWriteSegmentFun)(
        nsIInputStream* in_stream,
        void* closure,
        const char* from_segment,
        PRUint32 to_offset,
        PRUint32 count,
        PRUint32* write_count
);

%}
native nsWriteSegmentFun(nsWriteSegmentFun);

  
[scriptable, uuid(fa9c7f6c-61b3-11d4-9877-00c04fa0cf4a)]
interface nsIInputStream : nsISupports
{
     void close();
     unsigned long available();
     [noscript] unsigned long read(in charPtr buf, in unsigned long count);
     // this line wasn't compiling on VC6, so we'll use a void ptr for now
     //[noscript] unsigned long readSegments(in nsWriteSegmentFun writer, in voidPtr closure, in unsigned long count);
     [noscript] unsigned long readSegments(in voidPtr writer, in voidPtr closure, in unsigned long count);
     boolean isNonBlocking();
};




/**
 * nsIInputStreamChannel
 *
 * This interface provides methods to initialize an input stream channel.
 * The input stream channel serves as a data pump for an input stream.
 */
[scriptable, uuid(274c4d7a-2447-4ceb-a6de-80db1b83f5d2)]
interface nsIInputStreamChannel : nsISupports
{
    /**
     * Sets the URI for this channel.  This must be called before the
     * channel is opened, and it may only be called once.
     */
    void setURI(in nsIURI aURI);

    /**
     * Get/set the content stream
     *
     * This stream contains the data that will be pushed to the channel's
     * stream listener.  If the stream is non-blocking and supports the
     * nsIAsyncInputStream interface, then the stream will be read directly.
     * Otherwise, the stream will be read on a background thread.
     *
     * This attribute must be set before the channel is opened, and it may
     * only be set once.
     *
     * @throws NS_ERROR_IN_PROGRESS if the setter is called after the channel
     * has been opened.
     */
    attribute nsIInputStream contentStream;
};


///////////////////////////////////////////////////////////////////////////////
//  nsIIOService
///////////////////////////////////////////////////////////////////////////////


interface nsIProtocolHandler;
interface nsIChannel;


[scriptable, object, uuid(bddeda3f-9020-4d12-8c70-984ee9f7935e)]
interface nsIIOService : nsISupports
{
    nsIProtocolHandler getProtocolHandler(in string scheme);
    unsigned long getProtocolFlags(in string scheme);
    nsIURI newURI(in AUTF8String spec, in string origin_charset, in nsIURI base_uri);
    nsIURI newFileURI(in nsIFile file);
    nsIChannel newChannelFromURI(in nsIURI uri);
    nsIChannel newChannel(in AUTF8String spec,
                          in string origin_charset,
                          in nsIURI base_uri);
    
    attribute boolean offline;
    
    boolean allowPort(in long port, in string scheme);
    ACString extractScheme(in AUTF8String url_string);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIJSContextStack
///////////////////////////////////////////////////////////////////////////////


%{C++
struct JSContext;
%}

[ptr] native JSContext(JSContext);


[uuid(c67d8270-3189-11d3-9885-006008962422)]
interface nsIJSContextStack : nsISupports
{
    readonly attribute PRInt32 count;
    JSContext peek();
    JSContext pop();
    void push(in JSContext contxt);
};





///////////////////////////////////////////////////////////////////////////////
//  nsIMIMEInfo
///////////////////////////////////////////////////////////////////////////////


interface nsIUTF8StringEnumerator;
interface nsMIMEInfoHandleAction;
interface nsIHandlerApp;
interface nsIMutableArray;
interface nsIArray;
typedef long nsHandlerInfoAction;


[scriptable, uuid(325e56a7-3762-4312-aec7-f1fcf84b4145)] 
interface nsIHandlerInfo : nsISupports
{
    const long saveToDisk = 0;
    const long alwaysAsk = 1;
    const long useHelperApp = 2;
    const long handleInternally = 3;
    const long useSystemDefault = 4;
    
    readonly attribute ACString type;
    attribute AString description;
    attribute nsIHandlerApp preferredApplicationHandler;
    readonly attribute nsIMutableArray possibleApplicationHandlers;
    readonly attribute boolean hasDefaultHandler;
    readonly attribute AString defaultDescription;

    void launchWithURI(in nsIURI uri,
                       [optional] in nsIInterfaceRequestor window_context);

    attribute nsHandlerInfoAction preferredAction;

    attribute boolean alwaysAskBeforeHandling;
};


[scriptable, uuid(1c21acef-c7a1-40c6-9d40-a20480ee53a1)]
interface nsIMIMEInfo : nsIHandlerInfo
{
    nsIUTF8StringEnumerator getFileExtensions();
    
    void setFileExtensions(in AUTF8String extensions);
    boolean extensionExists(in AUTF8String extension);
    void appendExtension(in AUTF8String extension);
    
    attribute AUTF8String primaryExtension;
    readonly attribute ACString MIMEType;
    
    boolean equals(in nsIMIMEInfo mime_info);
    
    readonly attribute nsIArray possibleLocalHandlers;
    
    void launchWithFile(in nsIFile file);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIPrefService
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(e162bfa0-01bd-4e9f-9843-8fb2efcd6d1f)]
interface nsIPrefBranch : nsISupports
{
    const long PREF_INVALID = 0;
    const long PREF_STRING = 32;
    const long PREF_INT = 64;
    const long PREF_BOOL = 128;

    readonly attribute string root;
    
    long getPrefType(in string pref_name);
    
    boolean getBoolPref(in string pref_name);
    void setBoolPref(in string pref_name, in boolean val);
    
    string getCharPref(in string pref_name);
    void setCharPref(in string pref_name, in string val);
    
    long getIntPref(in string pref_name);
    void setIntPref(in string pref_name, in long val);
    
    void getComplexValue(in string pref_name, in nsIIDRef a_type,
                         [iid_is(a_type), retval] out nsQIResult val);

    void setComplexValue(in string pref_name, in nsIIDRef a_type, in nsISupports val);
    
    void clearUserPref(in string pref_name);
    void lockPref(in string pref_name);

    boolean prefHasUserValue(in string pref_name);
    boolean prefIsLocked(in string pref_name);
    void unlockPref(in string pref_name);
    
    void deleteBranch(in string starting_at);
    
    void getChildList(in string starting_at,
                    [optional] out unsigned long cnt,
                    [array, size_is(cnt), retval] out string child_arr);

    void resetBranch(in string starting_at);
};



[scriptable, uuid(decb9cc7-c08f-4ea5-be91-a8fc637ce2d2)]
interface nsIPrefService : nsISupports
{
    void readUserPrefs(in nsIFile aFile);
    void resetPrefs();
    void resetUserPrefs();

    void savePrefFile(in nsIFile aFile);
    nsIPrefBranch getBranch(in string aPrefRoot);
    nsIPrefBranch getDefaultBranch(in string aPrefRoot);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserPrint
///////////////////////////////////////////////////////////////////////////////

interface nsIPrintSettings;
interface nsIDOMWindow;
interface nsIWebProgressListener;


[scriptable, uuid(9a7ca4b0-fbba-11d4-a869-00105a183419)]
interface nsIWebBrowserPrint : nsISupports
{
    const short PRINTPREVIEW_GOTO_PAGENUM = 0;
    const short PRINTPREVIEW_PREV_PAGE = 1;
    const short PRINTPREVIEW_NEXT_PAGE = 2;
    const short PRINTPREVIEW_HOME = 3;
    const short PRINTPREVIEW_END = 4;

    readonly attribute nsIPrintSettings globalPrintSettings;
    readonly attribute nsIPrintSettings currentPrintSettings;
    readonly attribute nsIDOMWindow currentChildDOMWindow;
    readonly attribute boolean doingPrint;
    readonly attribute boolean doingPrintPreview;
    readonly attribute boolean isFramesetDocument;
    readonly attribute boolean isFramesetFrameSelected;
    readonly attribute boolean isIFrameSelected;
    readonly attribute boolean isRangeSelection;
    readonly attribute long printPreviewNumPages;

    void print(in nsIPrintSettings thePrintSettings,
               in nsIWebProgressListener WPListener);

    void printPreview(
                in nsIPrintSettings thePrintSettings,
                in nsIDOMWindow childDOMWin,
                in nsIWebProgressListener WPListener);

    void printPreviewNavigate(in short navType, in long pageNum);
    void cancel();
    void enumerateDocumentNames(
                out PRUint32 count,
                [retval, array, size_is(count)] out wstring result);
                
    void exitPrintPreview();
};


[scriptable, uuid(841387C8-72E6-484b-9296-BF6EEA80D58A)]
interface nsIPrintSettingsService : nsISupports
{
    readonly attribute nsIPrintSettings globalPrintSettings;
    readonly attribute nsIPrintSettings newPrintSettings;
    readonly attribute wstring defaultPrinterName;

    void initPrintSettingsFromPrinter(in wstring printer_name,
                                      in nsIPrintSettings print_settings);
                                      
    void initPrintSettingsFromPrefs(in nsIPrintSettings print_settings,
                                    in boolean use_printer_name_prefix,
                                    in unsigned long flags);
                                    
    void savePrintSettingsToPrefs(in nsIPrintSettings print_settings,
                                  in boolean user_printer_name_prefix,
                                  in unsigned long flags);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIPrintSettings
///////////////////////////////////////////////////////////////////////////////

interface nsIPrintSession;


[scriptable, uuid(343700dd-078b-42b6-a809-b9c1d7e951d0)]
interface nsIPrintSettings : nsISupports
{
    const unsigned long kInitSaveOddEvenPages = 0x1;
    const unsigned long kInitSaveHeaderLeft = 0x2;
    const unsigned long kInitSaveHeaderCenter = 0x4;
    const unsigned long kInitSaveHeaderRight = 0x8;
    const unsigned long kInitSaveFooterLeft = 0x10;
    const unsigned long kInitSaveFooterCenter = 0x20;
    const unsigned long kInitSaveFooterRight = 0x40;
    const unsigned long kInitSaveBGColors = 0x80;
    const unsigned long kInitSaveBGImages = 0x100;
    const unsigned long kInitSavePaperSize = 0x200;
    const unsigned long kInitSavePaperData = 0x2000;
    const unsigned long kInitSaveUnwriteableMargins = 0x4000;
    const unsigned long kInitSaveEdges = 0x8000;
    const unsigned long kInitSaveReversed = 0x10000;
    const unsigned long kInitSaveInColor = 0x20000;
    const unsigned long kInitSaveOrientation = 0x40000;
    const unsigned long kInitSavePrintCommand = 0x80000;
    const unsigned long kInitSavePrinterName = 0x100000;
    const unsigned long kInitSavePrintToFile = 0x200000;
    const unsigned long kInitSaveToFileName = 0x400000;
    const unsigned long kInitSavePageDelay = 0x800000;
    const unsigned long kInitSaveMargins = 0x1000000;
    const unsigned long kInitSaveNativeData = 0x2000000;
    const unsigned long kInitSavePlexName = 0x4000000;
    const unsigned long kInitSaveShrinkToFit = 0x8000000;
    const unsigned long kInitSaveScaling = 0x10000000;
    const unsigned long kInitSaveColorspace = 0x20000000;
    const unsigned long kInitSaveResolutionName = 0x40000000;
    const unsigned long kInitSaveDownloadFonts = 0x80000000;
    const unsigned long kInitSaveAll = 0xffffffff;
    const long kPrintOddPages = 0x1;
    const long kPrintEvenPages = 0x2;
    const long kEnableSelectionRB = 0x4;
    const long kRangeAllPages = 0;
    const long kRangeSpecifiedPageRange = 1;
    const long kRangeSelection = 2;
    const long kRangeFocusFrame = 3;
    const long kJustLeft = 0;
    const long kJustCenter = 1;
    const long kJustRight = 2;
    const short kUseInternalDefault = 0;
    const short kUseSettingWhenPossible = 1;
    const short kPaperSizeNativeData = 0;
    const short kPaperSizeDefined = 1;
    const short kPaperSizeInches = 0;
    const short kPaperSizeMillimeters = 1;
    const short kPortraitOrientation = 0;
    const short kLandscapeOrientation = 1;
    const short kNoFrames = 0;
    const short kFramesAsIs = 1;
    const short kSelectedFrame = 2;
    const short kEachFrameSep = 3;
    const short kFrameEnableNone = 0;
    const short kFrameEnableAll = 1;
    const short kFrameEnableAsIsAndEach = 2;
    const short kOutputFormatNative = 0;
    const short kOutputFormatPS = 1;
    const short kOutputFormatPDF = 2;
    
    void SetPrintOptions(in PRInt32 type, in boolean turn_on_off);
    boolean GetPrintOptions(in PRInt32 type);
    PRInt32 GetPrintOptionsBits();
    void GetEffectivePageSize(out double width, out double height);
    nsIPrintSettings clone();
    void assign(in nsIPrintSettings print_settings);

    [noscript] attribute nsIPrintSession printSession; /* We hold a weak reference */

    attribute long startPageRange; 
    attribute long endPageRange; 
    attribute double edgeTop;
    attribute double edgeLeft;
    attribute double edgeBottom;
    attribute double edgeRight;
    attribute double marginTop;
    attribute double marginLeft;
    attribute double marginBottom;
    attribute double marginRight;
    attribute double unwriteableMarginTop;
    attribute double unwriteableMarginLeft;
    attribute double unwriteableMarginBottom;
    attribute double unwriteableMarginRight;
    attribute double scaling;
    attribute boolean printBGColors;
    attribute boolean printBGImages;
    attribute short printRange; 
    attribute wstring title;
    attribute wstring docURL;
    attribute wstring headerStrLeft;
    attribute wstring headerStrCenter;
    attribute wstring headerStrRight;
    attribute wstring footerStrLeft;
    attribute wstring footerStrCenter;
    attribute wstring footerStrRight;
    attribute short howToEnableFrameUI;
    attribute boolean isCancelled;
    attribute short printFrameTypeUsage;
    attribute short printFrameType;
    attribute boolean printSilent;
    attribute boolean shrinkToFit;
    attribute boolean showPrintProgress;
    attribute wstring paperName;
    attribute short paperSizeType;
    attribute short paperData;
    attribute double paperWidth;
    attribute double paperHeight;
    attribute short paperSizeUnit;
    attribute wstring plexName;
    attribute wstring colorspace;
    attribute wstring resolutionName;
    attribute boolean downloadFonts;
    attribute boolean printReversed;
    attribute boolean printInColor;
    attribute long orientation;
    attribute wstring printCommand;
    attribute long numCopies;
    attribute wstring printerName;
    attribute boolean printToFile;
    attribute wstring toFileName;
    attribute short outputFormat;
    attribute long printPageDelay;
    attribute boolean isInitializedFromPrinter;
    attribute boolean isInitializedFromPrefs;
/*
    [noscript] void SetMarginInTwips(in nsNativeMarginRef aMargin);
    [noscript] void SetEdgeInTwips(in nsNativeMarginRef aEdge);
    [noscript] void GetMarginInTwips(in nsNativeMarginRef aMargin);
    [noscript] void GetEdgeInTwips(in nsNativeMarginRef aEdge);
    [noscript] void SetupSilentPrinting();
    [noscript] void SetUnwriteableMarginInTwips(in nsNativeMarginRef aEdge);
    [noscript] void GetUnwriteableMarginInTwips(in nsNativeMarginRef aEdge);
*/
};



///////////////////////////////////////////////////////////////////////////////
//  nsIPrintingPromptService
///////////////////////////////////////////////////////////////////////////////

interface nsIObserver;
interface nsIPrintProgressParams;

[scriptable, uuid(75D1553D-63BF-4b5d-A8F7-E4E4CAC21BA4)]
interface nsIPrintingPromptService : nsISupports
{
    void showPrintDialog(in nsIDOMWindow parent,
                         in nsIWebBrowserPrint webBrowserPrint,
                         in nsIPrintSettings printSettings);


    void showProgress(in nsIDOMWindow parent,
                      in nsIWebBrowserPrint webBrowserPrint,
                      in nsIPrintSettings printSettings,
                      in nsIObserver openDialogObserver,
                      in boolean isForPrinting,
                      out nsIWebProgressListener webProgressListener,
                      out nsIPrintProgressParams printProgressParams,
                      out boolean notifyOnOpen);

    void showPageSetup(
                       in nsIDOMWindow parent,
                       in nsIPrintSettings printSettings,
                       in nsIObserver aObs);

    void showPrinterProperties(
                     in nsIDOMWindow parent,
                     in wstring printerName,
                     in nsIPrintSettings printSettings);

};



///////////////////////////////////////////////////////////////////////////////
//  nsIPromptFactory
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(2532b748-75db-4732-9173-78d3bf34f694)]
interface nsIPromptFactory : nsISupports
{
    void getPrompt(in nsIDOMWindow aParent,
                   in nsIIDRef iid,
                   [iid_is(iid),retval] out nsQIResult result);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIPrompt
///////////////////////////////////////////////////////////////////////////////



[scriptable, uuid(a63f70c0-148b-11d3-9333-00104ba0fd40)]
interface nsIPrompt : nsISupports
{
    const unsigned long BUTTON_POS_0 = 1;
    const unsigned long BUTTON_POS_1 = 1 << 8;
    const unsigned long BUTTON_POS_2 = 1 << 16;

    const unsigned long BUTTON_TITLE_OK = 1;
    const unsigned long BUTTON_TITLE_CANCEL = 2;
    const unsigned long BUTTON_TITLE_YES = 3;
    const unsigned long BUTTON_TITLE_NO = 4;
    const unsigned long BUTTON_TITLE_SAVE = 5;
    const unsigned long BUTTON_TITLE_DONT_SAVE = 6;
    const unsigned long BUTTON_TITLE_REVERT = 7;

    const unsigned long BUTTON_TITLE_IS_STRING = 127;

    const unsigned long BUTTON_POS_0_DEFAULT = 0 << 24;
    const unsigned long BUTTON_POS_1_DEFAULT = 1 << 24;
    const unsigned long BUTTON_POS_2_DEFAULT = 2 << 24;

    const unsigned long BUTTON_DELAY_ENABLE = 1 << 26;

    const unsigned long STD_OK_CANCEL_BUTTONS = (BUTTON_TITLE_OK * BUTTON_POS_0) +(BUTTON_TITLE_CANCEL * BUTTON_POS_1);
    const unsigned long STD_YES_NO_BUTTONS = (BUTTON_TITLE_YES * BUTTON_POS_0) + (BUTTON_TITLE_NO * BUTTON_POS_1);
    
    void alert(in wstring dialogTitle,
               in wstring text);

    void alertCheck(in wstring dialogTitle,
                    in wstring text,
                    in wstring checkMsg,
                    inout boolean checkValue);

    boolean confirm(in wstring dialogTitle,
                    in wstring text);

    boolean confirmCheck(
                    in wstring dialogTitle,
                    in wstring text,
                    in wstring checkMsg,
                    inout boolean checkValue);

    PRInt32 confirmEx(
                    in wstring dialogTitle,
                    in wstring text,
                    in unsigned long buttonFlags,
                    in wstring button0Title,
                    in wstring button1Title,
                    in wstring button2Title,
                    in wstring checkMsg,
                    inout boolean checkValue);

    boolean prompt(in wstring dialogTitle,
                   in wstring text,
                   inout wstring value, 
                   in wstring checkMsg,
                   inout boolean checkValue);

    boolean promptPassword(
                   in wstring dialogTitle,
                   in wstring text,
                   inout wstring password,
                   in wstring checkMsg,
                   inout boolean checkValue);

    boolean promptUsernameAndPassword(
                   in wstring dialogTitle,
                   in wstring text,
                   inout wstring username,
                   inout wstring password,
                   in wstring checkMsg,
                   inout boolean checkValue);

    boolean select(in wstring dialogTitle,
                   in wstring text,
                   in PRUint32 count,
                   [array, size_is(count)] in wstring selectList,
                   out long outSelection);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIAuthInformation
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(0d73639c-2a92-4518-9f92-28f71fea5f20)]
interface nsIAuthInformation : nsISupports
{
    const PRUint32 AUTH_HOST = 1;
    const PRUint32 AUTH_PROXY = 2;
    const PRUint32 NEED_DOMAIN = 4;
    const PRUint32 ONLY_PASSWORD = 8;

    readonly attribute unsigned long flags;
    readonly attribute AString realm;
    readonly attribute AUTF8String authenticationScheme;
    attribute AString username;
    attribute AString password;
    attribute AString domain;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIAuthPrompt2
///////////////////////////////////////////////////////////////////////////////


interface nsIAuthPromptCallback;

[scriptable, uuid(651395EB-8612-4876-8AC0-A88D4DCE9E1E)]
interface nsIAuthPrompt2 : nsISupports
{         
    const PRUint32 LEVEL_NONE = 0;
    const PRUint32 LEVEL_PW_ENCRYPTED = 1;
    const PRUint32 LEVEL_SECURE = 2;

    boolean promptAuth(in nsIChannel aChannel,
                       in PRUint32 level,
                       in nsIAuthInformation authInfo);

    nsICancelable asyncPromptAuth(
                       in nsIChannel aChannel,
                       in nsIAuthPromptCallback aCallback,
                       in nsISupports aContext,
                       in PRUint32 level,
                       in nsIAuthInformation authInfo);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIPromptService
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;

[scriptable, uuid(1630c61a-325e-49ca-8759-a31b16c47aa5)]
interface nsIPromptService : nsISupports
{
    void alert(in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text);
               
    void alertCheck(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in wstring check_msg,
               inout boolean check_state);
               
    boolean confirm(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text);
               
    boolean confirmCheck(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in wstring check_msg,
               inout boolean check_state);
        
    const unsigned long BUTTON_POS_0 = 1;
    const unsigned long BUTTON_POS_1 = 256;
    const unsigned long BUTTON_POS_2 = 65536;
    const unsigned long BUTTON_TITLE_OK = 1;
    const unsigned long BUTTON_TITLE_CANCEL = 2;
    const unsigned long BUTTON_TITLE_YES = 3;
    const unsigned long BUTTON_TITLE_NO = 4;
    const unsigned long BUTTON_TITLE_SAVE = 5;
    const unsigned long BUTTON_TITLE_DONT_SAVE = 6;
    const unsigned long BUTTON_TITLE_REVERT = 7;
    const unsigned long BUTTON_TITLE_IS_STRING = 127;
    const unsigned long BUTTON_POS_0_DEFAULT = 0;
    const unsigned long BUTTON_POS_1_DEFAULT = 16777216;
    const unsigned long BUTTON_POS_2_DEFAULT = 33554432;
    const unsigned long BUTTON_DELAY_ENABLE = 67108864;
    const unsigned long STD_OK_CANCEL_BUTTONS = 513;
    const unsigned long STD_YES_NO_BUTTONS = 1027;
    
    
    PRInt32 confirmEx(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in unsigned long button_flags,
               in wstring button0_title,
               in wstring button1_title,
               in wstring button2_title,
               in wstring check_msg,
               inout boolean check_state);

    boolean prompt(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring value,
               in wstring check_msg,
               inout boolean check_state);

    boolean promptUsernameAndPassword(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring username,
               inout wstring password,
               in wstring check_msg,
               inout boolean check_state);

    boolean promptPassword(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring password,
               in wstring check_msg,
               inout boolean check_state);

    boolean select(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in PRUint32 count,
               [array, size_is(count)] in wstring select_list,
               out long out_selection);
};


interface nsIAuthInformation;
interface nsIAuthPromptCallback;

[scriptable, uuid(cf86d196-dbee-4482-9dfa-3477aa128319)]
interface nsIPromptService2 : nsIPromptService
{
    boolean promptAuth(
                in nsIDOMWindow parent,
                in nsIChannel channel,
                in PRUint32 level,
                in nsIAuthInformation auth_info,
                in wstring checkbox_label,
                inout boolean check_value);

    nsICancelable asyncPromptAuth(
                in nsIDOMWindow parent,
                in nsIChannel channel,
                in nsIAuthPromptCallback callbck,
                in nsISupports contxt,
                in PRUint32 level,
                in nsIAuthInformation auth_info,
                in wstring checkbox_label,
                inout boolean check_value);
};





///////////////////////////////////////////////////////////////////////////////
//  nsIProperties
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(78650582-4e93-4b60-8e85-26ebd3eb14ca)]
interface nsIProperties : nsISupports
{
    void get(in string prop_name,
             in nsIIDRef iid,
             [iid_is(iid), retval] out nsQIResult result);

    void set(in string prop_name,
             in nsISupports value);

    boolean has(in string prop_name);
    
    void undefine(in string prop_name);

    void getKeys(out PRUint32 count,
                 [array, size_is(count), retval] out string keys);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIRequestObserver
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;


[scriptable, uuid(fd91e2e0-1481-11d3-9333-00104ba0fd40)]
interface nsIRequestObserver : nsISupports
{
    void onStartRequest(in nsIRequest request,
                        in nsISupports contxt);
                        
    void onStopRequest(in nsIRequest request,
                       in nsISupports contxt,
                       in nsresult status_code);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIServiceManager
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(8bb35ed9-e332-462d-9155-4a002ab5c958)]
interface nsIServiceManager : nsISupports
{
    void getService(in nsCIDRef class_id,
                    in nsIIDRef iid,
                    [iid_is(iid), retval] out nsQIResult result);
                    
    void getServiceByContractID(
                    in string contract_id,
                    in nsIIDRef iid,
                    [iid_is(iid), retval] out nsQIResult result);
                    
    boolean isServiceInstantiated(
                    in nsCIDRef class_id,
                    in nsIIDRef iid);
                    
    boolean isServiceInstantiatedByContractID(
                    in string contract_id,
                    in nsIIDRef iid);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIStreamListener
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;
interface nsIInputStream;


[scriptable, uuid(1a637020-1482-11d3-9333-00104ba0fd40)]
interface nsIStreamListener : nsIRequestObserver
{
    void onDataAvailable(
            in nsIRequest request,
            in nsISupports contxt,
            in nsIInputStream input_stream,
            in unsigned long offset,
            in unsigned long count);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIStringInputStream
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(450cd2d4-f0fd-424d-b365-b1251f80fd53)]
interface nsIStringInputStream : nsIInputStream
{
    void setData(in string data, in long dataLen);
    [noscript] void adoptData(in charPtr data, in long data_len);
    [noscript] void shareData(in string data, in long data_len);
};




///////////////////////////////////////////////////////////////////////////////
//  nsITooltipListener
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(44b78386-1dd2-11b2-9ad2-e4eee2ca1916)]
interface nsITooltipListener : nsISupports
{
    void onShowTooltip(in long x_coords,
                       in long y_coords,
                       in wstring tip_text);
    void onHideTooltip();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebProgressListener
///////////////////////////////////////////////////////////////////////////////


interface nsIWebProgress;
interface nsIRequest;

[scriptable, uuid(570f39d1-efd0-11d3-b093-00a024ffc08c)]
interface nsIWebProgressListener : nsISupports
{
    const unsigned long STATE_START = 1;
    const unsigned long STATE_REDIRECTING = 2;
    const unsigned long STATE_TRANSFERRING = 4;
    const unsigned long STATE_NEGOTIATING = 8;
    const unsigned long STATE_STOP = 16;

    const unsigned long STATE_IS_REQUEST = 65536;
    const unsigned long STATE_IS_DOCUMENT = 131072;
    const unsigned long STATE_IS_NETWORK = 262144;
    const unsigned long STATE_IS_WINDOW = 524288;
    
    const unsigned long STATE_RESTORING = 16777216;

    const unsigned long STATE_IS_INSECURE = 4;
    const unsigned long STATE_IS_BROKEN = 1;
    const unsigned long STATE_IS_SECURE = 2;

    const unsigned long STATE_SECURE_HIGH = 262144;
    const unsigned long STATE_SECURE_MED = 65536;
    const unsigned long STATE_SECURE_LOW = 131072;

    void onStateChange(in nsIWebProgress web_progress,
                       in nsIRequest request,
                       in unsigned long state_flags,
                       in nsresult status);
                       
    void onProgressChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in long cur_self_progress,
                          in long max_self_progress,
                          in long cur_total_progress,
                          in long max_total_progress);
                      
    void onLocationChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in nsIURI location);
                          
    void onStatusChange(in nsIWebProgress web_progress,
                        in nsIRequest request,
                        in nsresult status,
                        in wstring message);
               
    void onSecurityChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in unsigned long state);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebProgressListener2
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(dde39de0-e4e0-11da-8ad9-0800200c9a66)]
interface nsIWebProgressListener2 : nsIWebProgressListener
{
    void onProgressChange64(in nsIWebProgress web_progress,
                            in nsIRequest request,
                            in long long cur_self_progress,
                            in long long max_self_progress,
                            in long long cur_total_progress,
                            in long long max_total_progress);

    boolean onRefreshAttempted(
                            in nsIWebProgress web_progress,
                            in nsIURI refresh_uri,
                            in long millis,
                            in boolean same_uri);
};


///////////////////////////////////////////////////////////////////////////////
//  nsITransfer
///////////////////////////////////////////////////////////////////////////////


interface nsIURI;
interface nsICancelable;
interface nsIMIMEInfo;
interface nsILocalFile;

[scriptable, uuid(3a982955-dc44-422e-8734-8462bf8d2121)]
interface nsITransfer : nsIWebProgressListener2 {

    /**
     * Initializes the transfer with certain properties.  This function must
     * be called prior to accessing any properties on this interface.
     *
     * @param aSource The source URI of the transfer. Must not be null.
     *
     * @param aTarget The target URI of the transfer. Must not be null.
     *
     * @param aDisplayName The user-readable description of the transfer.
     *                     Can be empty.
     *
     * @param aMIMEInfo The MIME info associated with the target,
     *                  including MIME type and helper app when appropriate.
     *                  This parameter is optional.
     *
     * @param startTime Time when the download started (ie, when the first
     *                  response from the server was received)
     *                  XXX presumably wbp and exthandler do this differently
     *
     * @param aTempFile The location of a temporary file; i.e. a file in which
     *                  the received data will be stored, but which is not
     *                  equal to the target file. (will be moved to the real
     *                  target by the caller, when the download is finished)
     *                  May be null.
     *
     * @param aCancelable An object that can be used to abort the download.
     *                    Must not be null.
     *                    Implementations are expected to hold a strong
     *                    reference to this object until the download is
     *                    finished, at which point they should release the
     *                    reference.
     */
    void init(in nsIURI aSource,
              in nsIURI aTarget,
              in AString aDisplayName,
              in nsIMIMEInfo aMIMEInfo,
              in PRTime startTime,
              in nsILocalFile aTempFile,
              in nsICancelable aCancelable);
};



/**
 * nsIMutable defines an interface to be implemented by objects which
 * can be made immutable.
 */
[scriptable, uuid(321578d0-03c1-4d95-8821-021ac612d18d)]
interface nsIMutable : nsISupports
{
    /**
     * Control whether or not this object can be modified.  If the flag is
     * false, no modification is allowed.  Once the flag has been set to false,
     * it cannot be reset back to true -- attempts to do so throw
     * NS_ERROR_INVALID_ARG.
     */
    attribute boolean mutable;
};


/**
 * nsIStandardURL defines the interface to an URL with the standard
 * file path format common to protocols like http, ftp, and file.
 * It supports initialization from a relative path and provides
 * some customization on how URLs are normalized.
 */
[scriptable, uuid(babd6cca-ebe7-4329-967c-d6b9e33caa81)]
interface nsIStandardURL : nsIMutable
{
    /**
     * blah:foo/bar    => blah://foo/bar
     * blah:/foo/bar   => blah:///foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah:///foo/bar
     */
    const unsigned long URLTYPE_STANDARD        = 1;

    /**
     * blah:foo/bar    => blah://foo/bar
     * blah:/foo/bar   => blah://foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah://foo/bar
     */
    const unsigned long URLTYPE_AUTHORITY       = 2;

    /**
     * blah:foo/bar    => blah:///foo/bar
     * blah:/foo/bar   => blah:///foo/bar
     * blah://foo/bar  => blah://foo/bar
     * blah:///foo/bar => blah:///foo/bar
     */
    const unsigned long URLTYPE_NO_AUTHORITY    = 3;

    /**
     * Initialize a standard URL.
     *
     * @param aUrlType       - one of the URLTYPE_ flags listed above.
     * @param aDefaultPort   - if the port parsed from the URL string matches
     *                         this port, then the port will be removed from the
     *                         canonical form of the URL.
     * @param aSpec          - URL string.
     * @param aOriginCharset - the charset from which this URI string
     *                         originated.  this corresponds to the charset
     *                         that should be used when communicating this
     *                         URI to an origin server, for example.  if
     *                         null, then provide aBaseURI implements this
     *                         interface, the origin charset of aBaseURI will
     *                         be assumed, otherwise defaulting to UTF-8 (i.e.,
     *                         no charset transformation from aSpec).
     * @param aBaseURI       - if null, aSpec must specify an absolute URI.
     *                         otherwise, aSpec will be resolved relative
     *                         to aBaseURI.
     */
    void init(in unsigned long aUrlType,
              in long aDefaultPort,
              in AUTF8String aSpec,
              in string aOriginCharset,
              in nsIURI aBaseURI);
};

///////////////////////////////////////////////////////////////////////////////
//  nsIURIContentListener
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;
interface nsIStreamListener;
interface nsIURIContentListener;

[scriptable, uuid(94928ab3-8b63-11d3-989d-001083010e9b)]
interface nsIURIContentListener : nsISupports
{
    boolean onStartURIOpen(in nsIURI uri);
    
    boolean doContent(in string content_type,
                      in boolean is_content_preferred,
                      in nsIRequest request,
                      out nsIStreamListener content_handler);
    
    boolean isPreferred(
                      in string content_type,
                      out string desired_content_type);
                      
    boolean canHandleContent(
                      in string content_type,
                      in boolean is_content_preferred,
                      out string desired_content_type);
               
    attribute nsISupports loadCookie;
    attribute nsIURIContentListener parentContentListener;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIURILoader
///////////////////////////////////////////////////////////////////////////////


interface nsIURIContentListener;
interface nsIChannel;
interface nsIInterfaceRequestor;
interface nsIStreamListener;


[scriptable, uuid(2f7e8051-f1c9-4bcc-8584-9cfd5849e343)]
interface nsIURILoader : nsISupports
{
    const unsigned long IS_CONTENT_PREFERRED = 0x01;
    const unsigned long DONT_RETARGET = 0x02;

    void registerContentListener(in nsIURIContentListener content_listener);
    void unRegisterContentListener(in nsIURIContentListener content_listener);
    
    void openURI(in nsIChannel channel,
                 in boolean is_content_preferred,
                 in nsIInterfaceRequestor window_context);
    
    nsIStreamListener openChannel(in nsIChannel channel,
                                  in unsigned long flags,
                                  in nsIInterfaceRequestor window_context);

    void stop(in nsISupports load_cookie);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowser
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowserChrome;
interface nsIURIContentListener;
interface nsIDOMWindow;
interface nsIWeakReference;

[scriptable, uuid(33e9d001-caab-4ba9-8961-54902f197202)]
interface nsIWebBrowser : nsISupports
{
    void addWebBrowserListener(in nsIWeakReference listener, in nsIIDRef iid);
    void removeWebBrowserListener(in nsIWeakReference listener, in nsIIDRef iid);
    
    attribute nsIWebBrowserChrome containerWindow;
    attribute nsIURIContentListener parentURIContentListener;
    readonly attribute nsIDOMWindow contentDOMWindow;
    attribute boolean isActive;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserChrome
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowser;

[scriptable, uuid(ba434c60-9d52-11d3-afb0-00a024ffc08c)]
interface nsIWebBrowserChrome : nsISupports
{
    void setStatus(in unsigned long status_type, in wstring status);
    attribute nsIWebBrowser webBrowser;
    
    const unsigned long STATUS_SCRIPT=0x00000001;
    const unsigned long STATUS_SCRIPT_DEFAULT=0x00000002;
    const unsigned long STATUS_LINK=0x00000003;

    const unsigned long CHROME_DEFAULT=0x00000001;
    const unsigned long CHROME_WINDOW_BORDERS=0x00000002;
    const unsigned long CHROME_WINDOW_CLOSE=0x00000004;
    const unsigned long CHROME_WINDOW_RESIZE=0x00000008;
    const unsigned long CHROME_MENUBAR=0x00000010;
    const unsigned long CHROME_TOOLBAR=0x00000020;
    const unsigned long CHROME_LOCATIONBAR=0x00000040;
    const unsigned long CHROME_STATUSBAR=0x00000080;
    const unsigned long CHROME_PERSONAL_TOOLBAR=0x00000100;
    const unsigned long CHROME_SCROLLBARS=0x00000200;
    const unsigned long CHROME_TITLEBAR=0x00000400;

    const unsigned long CHROME_WITH_SIZE=0x00001000;
    const unsigned long CHROME_WITH_POSITION=0x00002000;

    const unsigned long CHROME_WINDOW_MIN=0x00004000;
    const unsigned long CHROME_WINDOW_POPUP=0x00008000;
    const unsigned long CHROME_WINDOW_RAISED=0x02000000;
    const unsigned long CHROME_WINDOW_LOWERED=0x04000000;
    const unsigned long CHROME_CENTER_SCREEN=0x08000000;
    const unsigned long CHROME_DEPENDENT=0x10000000;
    const unsigned long CHROME_MODAL=0x20000000;
    const unsigned long CHROME_OPENAS_DIALOG=0x40000000;
    const unsigned long CHROME_OPENAS_CHROME =0x80000000;
    const unsigned long CHROME_ALL=0x00000ffe;
    
    attribute unsigned long chromeFlags;
    
    void destroyBrowserWindow();
    void sizeBrowserTo(in long cx, in long cy);
    void showAsModal();
    boolean isWindowModal();
    void exitModalEventLoop(in nsresult status);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserChromeFocus
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(d2206418-1dd1-11b2-8e55-acddcd2bcfb8)]
interface nsIWebBrowserChromeFocus : nsISupports
{
    void focusNextElement();
    void focusPrevElement();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserFind
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(2f977d44-5485-11d4-87e2-0010a4e75ef2)]
interface nsIWebBrowserFind : nsISupports
{
    boolean findNext();

    attribute wstring searchString;
    attribute boolean findBackwards;
    attribute boolean wrapFind;
    attribute boolean entireWord;
    attribute boolean matchCase;
    attribute boolean searchFrames;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserFocus
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;
interface nsIDOMElement;

[scriptable, uuid(9c5d3c58-1dd1-11b2-a1c9-f3699284657a)]
interface nsIWebBrowserFocus : nsISupports
{
    void activate();
    void deactivate();
    void setFocusAtFirstElement();
    void setFocusAtLastElement();
    
    attribute nsIDOMWindow focusedWindow;
    attribute nsIDOMElement focusedElement;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserPersist
///////////////////////////////////////////////////////////////////////////////


interface nsIChannel;
interface nsIWebProgressListener;
interface nsIInputStream;
interface nsIDOMDocument;


[scriptable, uuid(dd4e0a6a-210f-419a-ad85-40e8543b9465)]
interface nsIWebBrowserPersist : nsICancelable
{
    const unsigned long PERSIST_FLAGS_NONE = 0;
    const unsigned long PERSIST_FLAGS_FROM_CACHE = 1;
    const unsigned long PERSIST_FLAGS_BYPASS_CACHE = 2;
    const unsigned long PERSIST_FLAGS_IGNORE_REDIRECTED_DATA = 4;
    const unsigned long PERSIST_FLAGS_IGNORE_IFRAMES = 8;
    const unsigned long PERSIST_FLAGS_NO_CONVERSION = 16;
    const unsigned long PERSIST_FLAGS_REPLACE_EXISTING_FILES = 32;
    const unsigned long PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS = 64;
    const unsigned long PERSIST_FLAGS_FIXUP_ORIGINAL_DOM = 128;
    const unsigned long PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION = 256;
    const unsigned long PERSIST_FLAGS_DONT_FIXUP_LINKS = 512;
    const unsigned long PERSIST_FLAGS_SERIALIZE_OUTPUT = 1024;
    const unsigned long PERSIST_FLAGS_DONT_CHANGE_FILENAMES = 2048;
    const unsigned long PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS = 4096;
    const unsigned long PERSIST_FLAGS_CLEANUP_ON_FAILURE = 8192;
    const unsigned long PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION = 16384;
    
    const unsigned long PERSIST_STATE_READY = 1;
    const unsigned long PERSIST_STATE_SAVING = 2;
    const unsigned long PERSIST_STATE_FINISHED = 3;
    
    const unsigned long ENCODE_FLAGS_SELECTION_ONLY = 1;
    const unsigned long ENCODE_FLAGS_FORMATTED = 2;
    const unsigned long ENCODE_FLAGS_RAW = 4;
    const unsigned long ENCODE_FLAGS_BODY_ONLY = 8;
    const unsigned long ENCODE_FLAGS_PREFORMATTED = 16;
    const unsigned long ENCODE_FLAGS_WRAP = 32;
    const unsigned long ENCODE_FLAGS_FORMAT_FLOWED = 64;
    const unsigned long ENCODE_FLAGS_ABSOLUTE_LINKS = 128;
    const unsigned long ENCODE_FLAGS_ENCODE_W3C_ENTITIES = 256;
    const unsigned long ENCODE_FLAGS_CR_LINEBREAKS = 512;
    const unsigned long ENCODE_FLAGS_LF_LINEBREAKS = 1024;
    const unsigned long ENCODE_FLAGS_NOSCRIPT_CONTENT = 2048;
    const unsigned long ENCODE_FLAGS_NOFRAMES_CONTENT = 4096;
    const unsigned long ENCODE_FLAGS_ENCODE_BASIC_ENTITIES = 8192;
    const unsigned long ENCODE_FLAGS_ENCODE_LATIN1_ENTITIES = 16384;
    const unsigned long ENCODE_FLAGS_ENCODE_HTML_ENTITIES = 32768;

    attribute unsigned long persistFlags;
    readonly attribute unsigned long currentState;
    readonly attribute unsigned long result;
    attribute nsIWebProgressListener progressListener;
    
    void saveURI(in nsIURI uri,
                 in nsISupports cache_key,
                 in nsIURI referrer,
                 in nsIInputStream post_data,
                 in string extra_headers,
                 in nsIFile file);
                 
    void saveChannel(in nsIChannel channel,
                     in nsISupports file);
        
    void saveDocument(in nsIDOMDocument document,
                      in nsISupports file,
                      in nsISupports data_path,
                      in string output_content_type,
                      in unsigned long encoding_flags,
                      in unsigned long wrap_column);

    void cancelSave();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebNavigation
///////////////////////////////////////////////////////////////////////////////


interface nsIInputStream;
interface nsIDOMDocument;
interface nsISHistory;

[scriptable, uuid(f5d9e7b0-d930-11d3-b057-00a024ffc08c)]
interface nsIWebNavigation : nsISupports
{
    readonly attribute boolean canGoBack;
    readonly attribute boolean canGoForward;
    
    void goBack();
    void goForward();
    void gotoIndex(in long index);
    
    const unsigned long LOAD_FLAGS_MASK = 65535;
    const unsigned long LOAD_FLAGS_NONE = 0;
    const unsigned long LOAD_FLAGS_IS_REFRESH = 16;
    const unsigned long LOAD_FLAGS_IS_LINK = 32;
    const unsigned long LOAD_FLAGS_BYPASS_HISTORY = 64;
    const unsigned long LOAD_FLAGS_REPLACE_HISTORY = 128;
    const unsigned long LOAD_FLAGS_BYPASS_CACHE = 256;
    const unsigned long LOAD_FLAGS_BYPASS_PROXY = 512;
    const unsigned long LOAD_FLAGS_CHARSET_CHANGE = 1024;
    const unsigned long LOAD_FLAGS_STOP_CONTENT = 2048;
    const unsigned long LOAD_FLAGS_FROM_EXTERNAL = 4096;
    const unsigned long STOP_NETWORK = 1;
    const unsigned long STOP_CONTENT = 2;
    const unsigned long STOP_ALL = 3;
    
    void loadURI(in wstring uri,
                 in unsigned long load_flags,
                 in nsIURI referrer,
                 in nsIInputStream post_data,
                 in nsIInputStream headers);

    void reload(in unsigned long reload_flags);
    void stop(in unsigned long stop_flags);
    
    readonly attribute nsIDOMDocument document;
    readonly attribute nsIURI currentURI;
    readonly attribute nsIURI referringURI;
    attribute nsISHistory sessionHistory;
};


///////////////////////////////////////////////////////////////////////////////
//  nsISHistory
///////////////////////////////////////////////////////////////////////////////

interface nsIHistoryEntry;
interface nsISHistoryListener;
interface nsISimpleEnumerator;
/**
 * An interface to the primary properties of the Session History
 * component. In an embedded browser environment, the nsIWebBrowser
 * object creates an instance of session history for each open window.
 * A handle to the session history object can be obtained from
 * nsIWebNavigation. In a non-embedded situation, the  owner of the
 * session history component must create a instance of it and set
 * it in the nsIWebNavigation object.
 * This interface is accessible from javascript.
 */
 

%{C++
#define NS_SHISTORY_CID \
{0x7294fe9c, 0x14d8, 0x11d5, {0x98, 0x82, 0x00, 0xC0, 0x4f, 0xa0, 0x2f, 0x40}}

#define NS_SHISTORY_CONTRACTID "@mozilla.org/browser/shistory;1"
%}

[scriptable, uuid(ef2c9bcb-96b8-4095-933a-cb1c506f2c58)]
interface nsISHistory: nsISupports
{
  /**
   * A readonly property of the interface that returns 
   * the number of toplevel documents currently available
   * in session history.
   */
   readonly attribute long count;

  /**
   * A readonly property of the interface that returns 
   * the index of the current document in session history.
   */
   readonly attribute long index;

  /**
   * A readonly property of the interface that returns 
   * the index of the last document that started to load and
   * didn't finished yet. When document finishes the loading
   * value -1 is returned.
   */
   readonly attribute long requestedIndex;

  /**
   * A read/write property of the interface, used to Get/Set
   * the maximum number of toplevel documents, session history 
   * can hold for each instance. 
   */
   attribute long maxLength;

  /**
   * Called to obtain handle to the history entry at a
   * given index.
   *
   * @param index             The index value whose entry is requested.
   * @param modifyIndex       A boolean flag that indicates if the current
   *                          index of session history should be modified 
   *                          to the parameter index.
   *
   * @return                  <code>NS_OK</code> history entry for 
   *                          the index is obtained successfully.
   *                          <code>NS_ERROR_FAILURE</code> Error in obtaining
   *                          history entry for the given index.
   */
   nsIHistoryEntry getEntryAtIndex(in long index, in boolean modifyIndex);


  /**
   * Called to purge older documents from history.
   * Documents can be removed from session history for various 
   * reasons. For example to  control memory usage of the browser, to 
   * prevent users from loading documents from history, to erase evidence of
   * prior page loads etc...
   *
   * @param numEntries        The number of toplevel documents to be
   *                          purged from history. During purge operation,
   *                          the latest documents are maintained and older 
   *                          'numEntries' documents are removed from history.
   * @throws                  <code>NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA</code> Purge was vetod.
   * @throws                  <code>NS_ERROR_FAILURE</code> numEntries is
   *                          invalid or out of bounds with the size of history.
   *                          
   */
   void PurgeHistory(in long numEntries);

  /**
   * Called to register a listener for the session history component.
   * Listeners are notified when pages are loaded or purged from history.
   * 
   * @param aListener         Listener object to be notified for all
   *                          page loads that initiate in session history.
   *
   * @note                    A listener object must implement 
   *                          nsISHistoryListener and nsSupportsWeakReference
   *
   * @see nsISHistoryListener
   * @see nsSupportsWeakReference
   */
   void addSHistoryListener(in nsISHistoryListener aListener);

  /**
   * Called to remove a listener for the session history component.
   * Listeners are notified when pages are loaded from history.
   * 
   * @param aListener         Listener object to be removed from 
   *                          session history.
   *
   * @note                    A listener object must implement 
   *                          nsISHistoryListener and nsSupportsWeakReference
   * @see nsISHistoryListener
   * @see nsSupportsWeakReference
   */ 
   void removeSHistoryListener(in nsISHistoryListener aListener);

  /**
   * Called to obtain a enumerator for all the  documents stored in 
   * session history. The enumerator object thus returned by this method
   * can be traversed using nsISimpleEnumerator. 
   *
   * @note  To access individual history entries of the enumerator, perform the
   *        following steps:
   *        1) Call nsISHistory->GetSHistoryEnumerator() to obtain handle 
   *           the nsISimpleEnumerator object.
   *        2) Use nsISimpleEnumerator->GetNext() on the object returned
   *           by step #1 to obtain handle to the next object in the list. 
   *           The object returned by this step is of type nsISupports.
   *        3) Perform a QueryInterface on the object returned by step #2 
   *           to nsIHistoryEntry.
   *        4) Use nsIHistoryEntry to access properties of each history entry. 
   *
   * @see nsISimpleEnumerator
   * @see nsIHistoryEntry
   * @see QueryInterface()
   * @see do_QueryInterface()
   */
   readonly attribute nsISimpleEnumerator SHistoryEnumerator;

   void reloadCurrentEntry();
};


///////////////////////////////////////////////////////////////////////////////
//  nsIWindowCreator
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowserChrome;

[scriptable, uuid(30465632-a777-44cc-90f9-8145475ef999)]
interface nsIWindowCreator : nsISupports
{
    nsIWebBrowserChrome createChromeWindow(in nsIWebBrowserChrome parent,
                                           in unsigned long chrome_flags);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWindowWatcher
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;
interface nsIObserver;
interface nsISimpleEnumerator;
interface nsIAuthPrompt;
interface nsIWebBrowserChrome;
interface nsIPrompt;
interface nsIWindowCreator;

[scriptable, uuid(002286a8-494b-43b3-8ddd-49e3fc50622b)]
interface nsIWindowWatcher : nsISupports
{
    nsIDOMWindow openWindow(in nsIDOMWindow parent,
                            in string url,
                            in string name,
                            in string features,
                            in nsISupports arguments);
                            
    void registerNotification(in nsIObserver observer);
    void unregisterNotification(in nsIObserver observer);
    
    nsISimpleEnumerator getWindowEnumerator();
    nsIPrompt getNewPrompter(in nsIDOMWindow parent);
    nsIAuthPrompt getNewAuthPrompter(in nsIDOMWindow parent);
    void setWindowCreator(in nsIWindowCreator creator);
                            
    nsIWebBrowserChrome getChromeForWindow(in nsIDOMWindow window);
    
    nsIDOMWindow getWindowByName(in wstring target_name,
                                 in nsIDOMWindow current_window);
                                 
    attribute nsIDOMWindow activeWindow;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIXPCSecurityManager
///////////////////////////////////////////////////////////////////////////////


[ptr] native JSContextPtr(JSContext);
[ptr] native JSObjectPtr(JSObject);

interface nsIClassInfo;
interface nsIXPCNativeCallContext;

[uuid(31431440-f1ce-11d2-985a-006008962422)]
interface nsIXPCSecurityManager : nsISupports
{
    void CanCreateWrapper(
                   in JSContextPtr js_context,
                   in nsIIDRef iid,
                   in nsISupports obj,
                   in nsIClassInfo class_info,
                   inout voidPtr policy);

    void CanCreateInstance(
                   in JSContextPtr js_context,
                   in nsCIDRef cid);

    void CanGetService(
                   in JSContextPtr js_context,
                   in nsCIDRef cid);

    void CanAccess(in PRUint32 action,
                   in nsIXPCNativeCallContext call_context,
                   in JSContextPtr js_context,
                   in JSObjectPtr js_object,
                   in nsISupports obj,
                   in nsIClassInfo class_info,
                   in JSVal name,
                   inout voidPtr policy);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIPrincipal
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(B406A2DB-E547-4C95-B8E2-AD09ECB54CE0)]
interface nsIPrincipal : nsISupports //nsISerializable
{
    // TODO: fill out (if necessary)
    void placeholder();
};



///////////////////////////////////////////////////////////////////////////////
//  nsIScriptSecurityManager
///////////////////////////////////////////////////////////////////////////////

/* XXX: I'm not sure that these are the right definitions. */
[ptr] native jsid(ptrdiff_t);
[ptr] native JSStackFramePtr(void *);

[scriptable, uuid(50eda256-4dd2-4c7c-baed-96983910af9f)]
interface nsIScriptSecurityManager : nsIXPCSecurityManager
{
    ///////////////// Security Checks //////////////////
    /**
     * Checks whether the running script is allowed to access aProperty.
     */
    [noscript] void checkPropertyAccess(in JSContextPtr aJSContext,
                                        in JSObjectPtr aJSObject,
                                        in string aClassName,
                                        in jsid aProperty,
                                        in PRUint32 aAction);

    /**
     * Check that the script currently running in context "cx" can load "uri".
     *
     * Will return error code NS_ERROR_DOM_BAD_URI if the load request
     * should be denied.
     *
     * @param cx the JSContext of the script causing the load
     * @param uri the URI that is being loaded
     */
    [noscript] void checkLoadURIFromScript(in JSContextPtr cx, in nsIURI uri);

    /**
     * Default CheckLoadURI permissions
     */
    // Default permissions
    const unsigned long STANDARD = 0;

    // Indicate that the load is a load of a new document that is not
    // user-triggered.  Here "user-triggered" could be broadly interpreted --
    // for example, scripted sets of window.location.href might be treated as
    // "user-triggered" in some circumstances.  A typical example of a load
    // that is not user-triggered is a <meta> refresh load.  If this flag is
    // set, the load will be denied if the originating principal's URI has the
    // nsIProtocolHandler::URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT flag set.
    const unsigned long LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT = 1 << 0;

    // Allow the loading of chrome URLs by non-chrome URLs.  Use with great
    // care!  This will actually allow the loading of any URI which has the
    // nsIProtocolHandler::URI_IS_UI_RESOURCE protocol handler flag set.  Ths
    // probably means at least chrome: and resource:.
    const unsigned long ALLOW_CHROME = 1 << 1;

    // Don't allow URLs which would inherit the caller's principal (such as
    // javascript: or data:) to load.  See
    // nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT.
    const unsigned long DISALLOW_INHERIT_PRINCIPAL = 1 << 2;

    // Alias for DISALLOW_INHERIT_PRINCIPAL for backwards compat with
    // JS-implemented extensions.
    const unsigned long DISALLOW_SCRIPT_OR_DATA = DISALLOW_INHERIT_PRINCIPAL;

    // Don't allow javascript: URLs to load
    //   WARNING: Support for this value was added in Mozilla 1.7.8 and
    //   Firefox 1.0.4.  Use in prior versions WILL BE IGNORED.
    // When using this, make sure that you actually want DISALLOW_SCRIPT, not
    // DISALLOW_INHERIT_PRINCIPAL
    const unsigned long DISALLOW_SCRIPT = 1 << 3;

    /**
     * Check that content with principal aPrincipal can load "uri".
     *
     * Will return error code NS_ERROR_DOM_BAD_URI if the load request
     * should be denied.
     *
     * @param aPrincipal the principal identifying the actor causing the load
     * @param uri the URI that is being loaded
     * @param flags the permission set, see above
     */
    void checkLoadURIWithPrincipal(in nsIPrincipal aPrincipal,
                                   in nsIURI uri,
                                   in unsigned long flags);

    /**
     * Check that content from "from" can load "uri".
     *
     * Will return error code NS_ERROR_DOM_BAD_URI if the load request
     * should be denied.
     *
     * @param from the URI causing the load
     * @param uri the URI that is being loaded
     * @param flags the permission set, see above
     *
     * @deprecated Use checkLoadURIWithPrincipal instead of this function.
     */
    [deprecated] void checkLoadURI(in nsIURI from, in nsIURI uri,
                                   in unsigned long flags);

    /**
     * Similar to checkLoadURIWithPrincipal but there are two differences:
     *
     * 1) The URI is a string, not a URI object.
     * 2) This function assumes that the URI may still be subject to fixup (and
     * hence will check whether fixed-up versions of the URI are allowed to
     * load as well); if any of the versions of this URI is not allowed, this
     * function will return error code NS_ERROR_DOM_BAD_URI.
     */
    void checkLoadURIStrWithPrincipal(in nsIPrincipal aPrincipal,
                                      in AUTF8String uri,
                                      in unsigned long flags);

    /**
     * Same as CheckLoadURI but takes string arguments for ease of use
     * by scripts
     *
     * @deprecated Use checkLoadURIStrWithPrincipal instead of this function.
     */
    [deprecated] void checkLoadURIStr(in AUTF8String from, in AUTF8String uri,
                                      in unsigned long flags);

    /**
     * Check that the function 'funObj' is allowed to run on 'targetObj'
     *
     * Will return error code NS_ERROR_DOM_SECURITY_ERR if the function
     * should not run
     *
     * @param cx The current active JavaScript context.
     * @param funObj The function trying to run..
     * @param targetObj The object the function will run on.
     */
    [noscript] void checkFunctionAccess(in JSContextPtr cx, in voidPtr funObj,
                                        in voidPtr targetObj);

    /**
     * Return true if content from the given principal is allowed to
     * execute scripts.
     */
    [noscript] boolean canExecuteScripts(in JSContextPtr cx,
                                         in nsIPrincipal principal);

    ///////////////// Principals ///////////////////////
    /**
     * Return the principal of the innermost frame of the currently
     * executing script. Will return null if there is no script
     * currently executing.
     */
    [noscript] nsIPrincipal getSubjectPrincipal();

    /**
     * Return the all-powerful system principal.
     */
    nsIPrincipal getSystemPrincipal();

    /**
     * Return a principal with the specified certificate fingerprint, subject
     * name (the full name or concatenated set of names of the entity
     * represented by the certificate), pretty name, certificate, and
     * codebase URI.  The certificate fingerprint and subject name MUST be
     * nonempty; otherwise an error will be thrown.  Similarly, aCert must
     * not be null.
     */
    [noscript] nsIPrincipal
         getCertificatePrincipal(in AUTF8String aCertFingerprint,
                                 in AUTF8String aSubjectName,
                                 in AUTF8String aPrettyName,
                                 in nsISupports aCert,
                                 in nsIURI aURI);

    /**
     * Return a principal that has the same origin as aURI.
     */
    nsIPrincipal getCodebasePrincipal(in nsIURI aURI);

    ///////////////// Capabilities API /////////////////////
    /**
     * Request that 'capability' can be enabled by scripts or applets
     * running with 'principal'. Will prompt user if
     * necessary. Returns nsIPrincipal::ENABLE_GRANTED or
     * nsIPrincipal::ENABLE_DENIED based on user's choice.
     */
    [noscript] short requestCapability(in nsIPrincipal principal,
                                       in string capability);

    /**
     * Return true if the currently executing script has 'capability' enabled.
     */
    boolean isCapabilityEnabled(in string capability);

    /**
     * Enable 'capability' in the innermost frame of the currently executing
     * script.
     */
    void enableCapability(in string capability);

    /**
     * Remove 'capability' from the innermost frame of the currently
     * executing script. Any setting of 'capability' from enclosing
     * frames thus comes into effect.
     */
    void revertCapability(in string capability);

    /**
     * Disable 'capability' in the innermost frame of the currently executing
     * script.
     */
    void disableCapability(in string capability);

    //////////////// Master Certificate Functions ////////////////////
    /**
     * Allow 'certificateID' to enable 'capability.' Can only be performed
     * by code signed by the system certificate.
     */
    // XXXbz Capabilities can't have non-ascii chars?
    // XXXbz ideally we'd pass a subjectName here too, and the nsISupports
    // cert we're enabling for...
    void setCanEnableCapability(in AUTF8String certificateFingerprint,
                                in string capability,
                                in short canEnable);

    ///////////////////////
    /**
     * Return the principal of the specified object in the specified context.
     */
    [noscript] nsIPrincipal getObjectPrincipal(in JSContextPtr cx,
                                               in JSObjectPtr obj);

    /**
     * Returns true if the principal of the currently running script is the
     * system principal, false otherwise.
     */
    [noscript] boolean subjectPrincipalIsSystem();

    /**
     * Returns OK if aJSContext and target have the same "origin"
     * (scheme, host, and port).
     */
    [noscript] void checkSameOrigin(in JSContextPtr aJSContext,
                                    in nsIURI aTargetURI);

    /**
     * Returns OK if aSourceURI and target have the same "origin"
     * (scheme, host, and port).
     * ReportError flag suppresses error reports for functions that
     * don't need reporting.
     */
    void checkSameOriginURI(in nsIURI aSourceURI,
                            in nsIURI aTargetURI,
                            in boolean reportError);

    /**
     * Returns the principal of the global object of the given context, or null
     * if no global or no principal.
     */
    [noscript] nsIPrincipal getPrincipalFromContext(in JSContextPtr cx);

    /**
     * Get the principal for the given channel.  This will typically be the
     * channel owner if there is one, and the codebase principal for the
     * channel's URI otherwise.  aChannel must not be null.
     */
    nsIPrincipal getChannelPrincipal(in nsIChannel aChannel);

    /**
     * Check whether a given principal is a system principal.  This allows us
     * to avoid handing back the system principal to script while allowing
     * script to check whether a given principal is system.
     */
    boolean isSystemPrincipal(in nsIPrincipal aPrincipal);

    /**
     * Same as getSubjectPrincipal(), only faster. cx must *never* be
     * passed null, and it must be the context on the top of the
     * context stack. Does *not* reference count the returned
     * principal.
     */
    [noscript,notxpcom] nsIPrincipal getCxSubjectPrincipal(in JSContextPtr cx);
    [noscript,notxpcom] nsIPrincipal getCxSubjectPrincipalAndFrame(in JSContextPtr cx,
                                                                   out JSStackFramePtr fp);

    /**
     * If no scripted code is running "above" (or called from) fp, then
     * instead of looking at cx->globalObject, we will return |principal|.
     * This function only affects |cx|. If someone pushes another context onto
     * the context stack, then it supersedes this call.
     * NOTE: If |fp| is non-null popContextPrincipal must be called before fp
     * has finished executing.
     *
     * @param cx The context to clamp.
     * @param fp The frame pointer to clamp at. May be 'null'.
     * @param principal The principal to clamp to.
     */
    [noscript] void pushContextPrincipal(in JSContextPtr cx,
                                         in JSStackFramePtr fp,
                                         in nsIPrincipal principal);

    /**
     * Removes a clamp set by pushContextPrincipal from cx. This must be
     * called in a stack-like fashion (e.g., given two contexts |a| and |b|,
     * it is not legal to do: push(a) push(b) pop(a)).
     */
    [noscript] void popContextPrincipal(in JSContextPtr cx);
};



/**
 * nsIProtocolHandler
 */
[scriptable, uuid(15fd6940-8ea7-11d3-93ad-00104ba0fd40)]
interface nsIProtocolHandler : nsISupports
{
    /**
     * The scheme of this protocol (e.g., "file").
     */
    readonly attribute ACString scheme;

    /** 
     * The default port is the port that this protocol normally uses.
     * If a port does not make sense for the protocol (e.g., "about:")
     * then -1 will be returned.
     */
    readonly attribute long defaultPort;

    /**
     * Returns the protocol specific flags (see flag definitions below).  
     */
    readonly attribute unsigned long protocolFlags;

    /**
     * Makes a URI object that is suitable for loading by this protocol,
     * where the URI string is given as an UTF-8 string.  The caller may
     * provide the charset from which the URI string originated, so that
     * the URI string can be translated back to that charset (if necessary)
     * before communicating with, for example, the origin server of the URI
     * string.  (Many servers do not support UTF-8 IRIs at the present time,
     * so we must be careful about tracking the native charset of the origin
     * server.)
     *
     * @param aSpec          - the URI string in UTF-8 encoding. depending
     *                         on the protocol implementation, unicode character
     *                         sequences may or may not be %xx escaped.
     * @param aOriginCharset - the charset of the document from which this URI
     *                         string originated.  this corresponds to the
     *                         charset that should be used when communicating
     *                         this URI to an origin server, for example.  if
     *                         null, then UTF-8 encoding is assumed (i.e.,
     *                         no charset transformation from aSpec).
     * @param aBaseURI       - if null, aSpec must specify an absolute URI.
     *                         otherwise, aSpec may be resolved relative
     *                         to aBaseURI, depending on the protocol. 
     *                         If the protocol has no concept of relative 
     *                         URI aBaseURI will simply be ignored.
     */
    nsIURI newURI(in AUTF8String aSpec,
                  in string aOriginCharset,
                  in nsIURI aBaseURI);

    /**
     * Constructs a new channel from the given URI for this protocol handler. 
     */
    nsIChannel newChannel(in nsIURI aURI);

    /**
     * Allows a protocol to override blacklisted ports.
     *
     * This method will be called when there is an attempt to connect to a port 
     * that is blacklisted.  For example, for most protocols, port 25 (Simple Mail
     * Transfer) is banned.  When a URI containing this "known-to-do-bad-things" 
     * port number is encountered, this function will be called to ask if the 
     * protocol handler wants to override the ban.  
     */
    boolean allowPort(in long port, in string scheme);


    /**************************************************************************
     * Constants for the protocol flags (the first is the default mask, the
     * others are deviations):
     *
     * NOTE: Implementation must ignore any flags they do not understand.
     */

    /**
     * standard full URI with authority component and concept of relative
     * URIs (http, ftp, ...)
     */
    const unsigned long URI_STD = 0;

    /**
     * no concept of relative URIs (about, javascript, finger, ...)
     */
    const unsigned long URI_NORELATIVE = (1<<0);

    /**
     * no authority component (file, ...)
     */
    const unsigned long URI_NOAUTH = (1<<1);

    /**
     * The URIs for this protocol have no inherent security context, so
     * documents loaded via this protocol should inherit the security context
     * from the document that loads them.
     */
    const unsigned long URI_INHERITS_SECURITY_CONTEXT = (1<<4);

    /**
     * "Automatic" loads that would replace the document (e.g. <meta> refresh,
     * certain types of XLinks, possibly other loads that the application
     * decides are not user triggered) are not allowed if the originating (NOT
     * the target) URI has this protocol flag.  Note that the decision as to
     * what constitutes an "automatic" load is made externally, by the caller
     * of nsIScriptSecurityManager::CheckLoadURI.  See documentation for that
     * method for more information.
     *
     * A typical protocol that might want to set this flag is a protocol that
     * shows highly untrusted content in a viewing area that the user expects
     * to have a lot of control over, such as an e-mail reader.
     */
    const unsigned long URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT = (1<<5);

    /**
     * +-------------------------------------------------------------------+
     * |                                                                   |
     * |  ALL PROTOCOL HANDLERS MUST SET ONE OF THE FOLLOWING FIVE FLAGS.  |
     * |                                                                   |
     * +-------------------------------------------------------------------+
     *
     * These flags are used to determine who is allowed to load URIs for this
     * protocol.  Note that if a URI is nested, only the flags for the
     * innermost URI matter.  See nsINestedURI.
     *
     * If none of these five flags are set, the URI must be treated as if it
     * had the URI_LOADABLE_BY_ANYONE flag set, for compatibility with protocol
     * handlers written against Gecko 1.8 or earlier.  In this case, there may
     * be run-time warning messages indicating that a "default insecure"
     * assumption is being made.  At some point in the futures (Mozilla 2.0,
     * most likely), these warnings will become errors.
     */

    /**
     * The URIs for this protocol can be loaded by anyone.  For example, any
     * website should be allowed to trigger a load of a URI for this protocol.
     * Web-safe protocols like "http" should set this flag.
     */
    const unsigned long URI_LOADABLE_BY_ANYONE = (1<<6);
    
    /**
     * The URIs for this protocol are UNSAFE if loaded by untrusted (web)
     * content and may only be loaded by privileged code (for example, code
     * which has the system principal).  Various internal protocols should set
     * this flag.
     */
    const unsigned long URI_DANGEROUS_TO_LOAD = (1<<7);
    
    /**
     * The URIs for this protocol point to resources that are part of the
     * application's user interface.  There are cases when such resources may
     * be made accessible to untrusted content such as web pages, so this is
     * less restrictive than URI_DANGEROUS_TO_LOAD but more restrictive than
     * URI_LOADABLE_BY_ANYONE.  See the documentation for
     * nsIScriptSecurityManager::CheckLoadURI.
     */
    const unsigned long URI_IS_UI_RESOURCE = (1<<8);

    /**
     * Loading of URIs for this protocol from other origins should only be
     * allowed if those origins should have access to the local filesystem.
     * It's up to the application to decide what origins should have such
     * access.  Protocols like "file" that point to local data should set this
     * flag.
     */
    const unsigned long URI_IS_LOCAL_FILE = (1<<9);

    /**
     * The URIs for this protocol can be loaded only by callers with a
     * principal that subsumes this uri. For example, privileged code and
     * websites that are same origin as this uri.
     */
    const unsigned long URI_LOADABLE_BY_SUBSUMERS = (1<<14);

    /**
     * Loading channels from this protocol has side-effects that make
     * it unsuitable for saving to a local file.
     */
    const unsigned long URI_NON_PERSISTABLE = (1<<10);

    /**
     * Channels using this protocol never call OnDataAvailable
     * on the listener passed to AsyncOpen and they therefore
     * do not return any data that we can use.
     */
    const unsigned long URI_DOES_NOT_RETURN_DATA = (1<<11);

    /**
     * URIs for this protocol are considered to be local resources.  This could
     * be a local file (URI_IS_LOCAL_FILE), a UI resource (URI_IS_UI_RESOURCE),
     * or something else that would not hit the network.
     */
    const unsigned long URI_IS_LOCAL_RESOURCE = (1<<12);

    /**
     * URIs for this protocol execute script when they are opened.
     */
    const unsigned long URI_OPENING_EXECUTES_SCRIPT = (1<<13);

    // Note that 1 << 14 is used above

    /**
     * This protocol handler can be proxied via a proxy (socks or http)
     * (e.g., irc, smtp, http, etc.).  If the protocol supports transparent
     * proxying, the handler should implement nsIProxiedProtocolHandler.
     *
     * If it supports only HTTP proxying, then it need not support
     * nsIProxiedProtocolHandler, but should instead set the ALLOWS_PROXY_HTTP
     * flag (see below).
     *
     * @see nsIProxiedProtocolHandler
     */
    const unsigned long ALLOWS_PROXY = (1<<2);

    /**
     * This protocol handler can be proxied using a http proxy (e.g., http,
     * ftp, etc.).  nsIIOService::newChannelFromURI will feed URIs from this
     * protocol handler to the HTTP protocol handler instead.  This flag is
     * ignored if ALLOWS_PROXY is not set.
     */
    const unsigned long ALLOWS_PROXY_HTTP = (1<<3);
};

%{C++
/**
 * Protocol handlers are registered with XPCOM under the following CONTRACTID prefix:
 */
#define NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "@mozilla.org/network/protocol;1?name="
/**
 * For example, "@mozilla.org/network/protocol;1?name=http"
 */
%}


%{C++
// {0A698C44-3BFF-11d4-9649-00C0CA135B4E}
#define NS_ISCRIPTABLEUNICODECONVERTER_CID { 0x0A698C44, 0x3BFF, 0x11d4, { 0x96, 0x49, 0x00, 0xC0, 0xCA, 0x13, 0x5B, 0x4E } }
#define NS_ISCRIPTABLEUNICODECONVERTER_CONTRACTID "@mozilla.org/intl/scriptableunicodeconverter"
%}

/**
 * This interface is a unicode encoder for use by scripts
 *
 * @created         8/Jun/2000
 * @author          Makoto Kato [m_kato@ga2.so-net.ne.jp]
 */
[scriptable, uuid(f36ee324-5c1c-437f-ba10-2b4db7a18031)]
interface nsIScriptableUnicodeConverter : nsISupports
{
  /**
   * Converts the data from Unicode to one Charset.
   * Returns the converted string. After converting, Finish should be called
   * and its return value appended to this return value.
   */
  ACString ConvertFromUnicode(in AString aSrc);

  /**
   * Returns the terminator string.
   * Should be called after ConvertFromUnicode() and appended to that
   * function's return value.
   */
  ACString Finish();

  /**
   * Converts the data from one Charset to Unicode.
   */
  AString ConvertToUnicode(in ACString aSrc);

  /**
   * Converts an array of bytes to a unicode string.
   */
  AString convertFromByteArray([const,array,size_is(aCount)] in octet aData,
                               in unsigned long aCount);

  /**
   * Convert a unicode string to an array of bytes. Finish does not need to be
   * called.
   */
  void convertToByteArray(in AString aString,
                          [optional] out unsigned long aLen,
                          [array, size_is(aLen),retval] out octet aData);

  /**
   * Converts a unicode string to an input stream. The bytes in the stream are
   * encoded according to the charset attribute.
   * The returned stream will be nonblocking.
   */
  nsIInputStream convertToInputStream(in AString aString);

  /**
   * Current character set.
   *
   * @throw NS_ERROR_UCONV_NOCONV
   *        The requested charset is not supported.
   */
  attribute string charset;

  /**
   * Internal use
   *
   * When this attribute is set, all charsets may be accessed.
   * When it is not set (the default), charsets with the isXSSVulnerable flag
   *  may not be accessed
   */
  attribute boolean isInternal;
};


[ptr] native nsNonConstIDPtr(nsID);

/**
 * nsIUUIDGenerator is implemented by a service that can generate
 * universally unique identifiers, ideally using any platform-native
 * method for generating UUIDs.
 */
[scriptable, uuid(138ad1b2-c694-41cc-b201-333ce936d8b8)]
interface nsIUUIDGenerator : nsISupports
{
  /**
   * Obtains a new UUID using appropriate platform-specific methods to
   * obtain a nsID that can be considered to be globally unique.
   *
   * @returns an nsID filled in with a new UUID.
   *
   * @throws NS_ERROR_FAILURE if a UUID cannot be generated (e.g. if
   * an underlying source of randomness is not available)
   */
  nsIDPtr generateUUID();

  /**
   * Obtain a new UUID like the generateUUID method, but place it in
   * the provided nsID pointer instead of allocating a new nsID.
   *
   * @param id an existing nsID pointer where the UUID will be stored.
   *
   * @throws NS_ERROR_FAILURE if a UUID cannot be generated (e.g. if
   * an underlying source of randomness is not available)
   */
  [noscript] void generateUUIDInPlace(in nsNonConstIDPtr id);
};

///////////////////////////////////////////////////////////////////////////////
//  nsISSLCertErrorDialog
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(0729ce8e-8935-4989-ba72-a2d6307f2365)]
interface nsISSLCertErrorDialog : nsISupports
{
    void showCertError(in nsIInterfaceRequestor ctx, 
                       in nsISSLStatus status,
                       in nsIX509Cert cert,
                       in AString text_error_message,
                       in AString html_error_message,
                       in ACString host_name,
                       in PRUint32 port_number);
};




%{ C++
class nsPresContext;
class nsIPresShell;
struct JSContext;
%}

/**
 * The nsIDocShell interface.
 */

[ptr] native nsPresContext(nsPresContext);
[ptr] native nsIPresShell(nsIPresShell);

interface nsIURI;
interface nsIChannel;
interface nsIContentViewer;
interface nsIURIContentListener;
interface nsIDOMEventTarget;
interface nsIDocShellLoadInfo;
interface nsIDocumentCharsetInfo;
interface nsIWebNavigation;
interface nsISimpleEnumerator;
interface nsIInputStream;
interface nsIRequest;
interface nsISHEntry;
interface nsILayoutHistoryState;
interface nsISecureBrowserUI;
interface nsIDOMStorage;
interface nsIPrincipal;
interface nsIWebBrowserPrint;
interface nsIVariant;

[scriptable, uuid(0666adf8-8738-4ca7-a917-0348f47d2f40)]
interface nsIDocShell : nsISupports
{
  /**
   * Loads a given URI.  This will give priority to loading the requested URI
   * in the object implementing	this interface.  If it can't be loaded here
   * however, the URL dispatcher will go through its normal process of content
   * loading.
   *
   * @param uri        - The URI to load.
   * @param loadInfo   - This is the extended load info for this load.  This
   *                     most often will be null, but if you need to do 
   *                     additional setup for this load you can get a loadInfo
   *                     object by calling createLoadInfo.  Once you have this
   *                     object you can set the needed properties on it and
   *                     then pass it to loadURI.
   * @param aLoadFlags - Flags to modify load behaviour. Flags are defined in
   *                     nsIWebNavigation.  Note that using flags outside
   *                     LOAD_FLAGS_MASK is only allowed if passing in a
   *                     non-null loadInfo.  And even some of those might not
   *                     be allowed.  Use at your own risk.
   */
  [noscript]void loadURI(in nsIURI uri,
                         in nsIDocShellLoadInfo loadInfo,
                         in unsigned long aLoadFlags,
                         in boolean firstParty);

  /**
   * Loads a given stream. This will give priority to loading the requested
   * stream in the object implementing this interface. If it can't be loaded
   * here however, the URL dispatched will go through its normal process of
   * content loading.
   *
   * @param aStream         - The input stream that provides access to the data
   *                          to be loaded.  This must be a blocking, threadsafe
   *                          stream implementation.
   * @param aURI            - The URI representing the stream, or null.
   * @param aContentType    - The type (MIME) of data being loaded (empty if unknown).
   * @param aContentCharset - The charset of the data being loaded (empty if unknown).
   * @param aLoadInfo       - This is the extended load info for this load.  This
   *                          most often will be null, but if you need to do 
   *                          additional setup for this load you can get a
   *                          loadInfo object by calling createLoadInfo.  Once
   *                          you have this object you can set the needed 
   *                          properties on it and then pass it to loadStream.
   */
  [noscript]void loadStream(in nsIInputStream aStream,
                            in nsIURI aURI,
                            in ACString aContentType,
                            in ACString aContentCharset,
                            in nsIDocShellLoadInfo aLoadInfo);

  const long INTERNAL_LOAD_FLAGS_NONE                    = 0x0;
  const long INTERNAL_LOAD_FLAGS_INHERIT_OWNER           = 0x1;
  const long INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER      = 0x2;
  const long INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP = 0x4;

  // This flag marks the first load in this object
  // @see nsIWebNavigation::LOAD_FLAGS_FIRST_LOAD
  const long INTERNAL_LOAD_FLAGS_FIRST_LOAD              = 0x8;

  const long INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER       = 0x10;
  const long INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES     = 0x20;

  /**
   * Loads the given URI.  This method is identical to loadURI(...) except
   * that its parameter list is broken out instead of being packaged inside
   * of an nsIDocShellLoadInfo object...
   *
   * @param aURI            - The URI to load.
   * @param aReferrer       - Referring URI
   * @param aOwner          - Owner (security principal) 
   * @param aInheritOwner   - Flag indicating whether the owner of the current
   *                          document should be inherited if aOwner is null.
   * @param aStopActiveDoc  - Flag indicating whether loading the current
   *                          document should be stopped.
   * @param aWindowTarget   - Window target for the load.
   * @param aTypeHint       - A hint as to the content-type of the resulting
   *                          data.  May be null or empty if no hint.
   * @param aPostDataStream - Post data stream (if POSTing)
   * @param aHeadersStream  - Stream containing "extra" request headers...
   * @param aLoadFlags      - Flags to modify load behaviour. Flags are defined
   *                          in nsIWebNavigation.
   * @param aSHEntry        - Active Session History entry (if loading from SH)
   */
  [noscript]void internalLoad(in nsIURI aURI,
                              in nsIURI aReferrer,
                              in nsISupports aOwner,
                              in PRUint32 aFlags,
                              in wstring aWindowTarget,
                              in string aTypeHint,
                              in nsIInputStream aPostDataStream,
                              in nsIInputStream aHeadersStream,
                              in unsigned long aLoadFlags,
                              in nsISHEntry aSHEntry,
                              in boolean firstParty,
                              out nsIDocShell aDocShell,
                              out nsIRequest aRequest);

  /**
   * Do either a history.pushState() or history.replaceState() operation,
   * depending on the value of aReplace.
   */
  [implicit_jscontext]
  void addState(in nsIVariant aData, in DOMString aTitle,
                in DOMString aURL, in boolean aReplace);

  /**
   * Creates a DocShellLoadInfo object that you can manipulate and then pass
   * to loadURI.
   */
  void createLoadInfo(out nsIDocShellLoadInfo loadInfo);

  /**
   * Reset state to a new content model within the current document and the document
   * viewer.  Called by the document before initiating an out of band document.write().
   */
  void prepareForNewContentModel();

  /**
   * For editors and suchlike who wish to change the URI associated with the
   * document. Note if you want to get the current URI, use the read-only
   * property on nsIWebNavigation.
   */ 
  void setCurrentURI(in nsIURI aURI);

  /**
   * Notify the associated content viewer and all child docshells that they are
   * about to be hidden.  If |isUnload| is true, then the document is being
   * unloaded as well.
   *
   * @param isUnload if true, fire the unload event in addition to the pagehide
   *                 event.
   */
  [noscript] void firePageHideNotification(in boolean isUnload);

  /**
   * Presentation context for the currently loaded document.  This may be null.
   */
  [noscript] readonly attribute nsPresContext presContext;

  /**
   * Presentation shell for the currently loaded document.  This may be null.
   */
  [noscript] readonly attribute nsIPresShell presShell;

  /**
   * Presentation shell for the oldest document, if this docshell is
   * currently transitioning between documents.
   */
  [noscript] readonly attribute nsIPresShell eldestPresShell;

  /**
   * Content Viewer that is currently loaded for this DocShell.  This may
   * change as the underlying content changes.
   */
  readonly attribute nsIContentViewer contentViewer;

  /**
   * This attribute allows chrome to tie in to handle DOM events that may
   * be of interest to chrome.
   */
  attribute nsIDOMEventTarget chromeEventHandler;

  /**
   * The document charset info.  This is used by a load to determine priorities
   * for charset detection etc.
   */
  attribute nsIDocumentCharsetInfo documentCharsetInfo;

  /**
   * Whether to allow plugin execution
   */
  attribute boolean allowPlugins;

  /**
   * Whether to allow Javascript execution
   */
  attribute boolean allowJavascript;

  /**
   * Attribute stating if refresh based redirects can be allowed
   */
  attribute  boolean allowMetaRedirects;

  /**
   * Attribute stating if it should allow subframes (framesets/iframes) or not
   */
  attribute boolean allowSubframes;

  /**
   * Attribute stating whether or not images should be loaded.
   */
  attribute boolean allowImages;

  /**
   * Attribute that determines whether DNS prefetch is allowed for this subtree
   * of the docshell tree.  Defaults to true.  Setting this will make it take
   * effect starting with the next document loaded in the docshell.
   */
  attribute boolean allowDNSPrefetch;

  /**
   * Attribute that determines whether window control (move/resize) is allowed.
   */
  attribute boolean allowWindowControl;

  /**
   * Get an enumerator over this docShell and its children.
   *
   * @param aItemType  - Only include docShells of this type, or if typeAll,
   *                     include all child shells.
   *                     Uses types from nsIDocShellTreeItem.
   * @param aDirection - Whether to enumerate forwards or backwards.
   */

  const long ENUMERATE_FORWARDS  = 0;
  const long ENUMERATE_BACKWARDS = 1;

  nsISimpleEnumerator getDocShellEnumerator(in long aItemType,
                                            in long aDirection);

  /**
   * The type of application that created this window
   */
  const unsigned long APP_TYPE_UNKNOWN  = 0;
  const unsigned long APP_TYPE_MAIL     = 1;
  const unsigned long APP_TYPE_EDITOR   = 2;

  attribute unsigned long appType;

  /**
   * certain dochshells (like the message pane)
   * should not throw up auth dialogs
   * because it can act as a password trojan
   */
  attribute boolean allowAuth;

  /**
   * Set/Get the document scale factor.  When setting this attribute, a
   * NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
   * not supporting zoom.  Implementations not supporting zoom should return
   * 1.0 all the time for the Get operation.  1.0 by the way is the default
   * of zoom.  This means 100% of normal scaling or in other words normal size
   * no zoom. 
   */
  attribute float zoom;

  /*
   * The size, in CSS pixels, of the horizontal margins for the <body> of an
   * HTML document in this docshel; used to implement the marginwidth attribute
   * on HTML <frame>/<iframe> elements.  A value smaller than zero indicates
   * that the attribute was not set.
   */
  attribute long marginWidth;

  /*
   * The size, in CSS pixels, of the vertical margins for the <body> of an HTML
   * document in this docshel; used to implement the marginheight attribute on
   * HTML <frame>/<iframe> elements.  A value smaller than zero indicates that
   * the attribute was not set.
   */
  attribute long marginHeight;

  /*
   * Tells the docshell to offer focus to its tree owner.
   * This is currently only necessary for embedding chrome.
   */
  void tabToTreeOwner(in boolean forward,
                      out boolean tookFocus);

  /**
   * Current busy state for DocShell
   */
  const unsigned long BUSY_FLAGS_NONE             = 0;
  const unsigned long BUSY_FLAGS_BUSY             = 1;
  const unsigned long BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
  const unsigned long BUSY_FLAGS_PAGE_LOADING     = 4;

  /**
   * Load commands for the document 
   */
  const unsigned long LOAD_CMD_NORMAL  = 0x1;   // Normal load
  const unsigned long LOAD_CMD_RELOAD  = 0x2;   // Reload
  const unsigned long LOAD_CMD_HISTORY = 0x4;   // Load from history
  const unsigned long LOAD_CMD_PUSHSTATE = 0x8; // History.pushState()

  readonly attribute unsigned long busyFlags;

  /* 
   * attribute to access the loadtype  for the document
   */
  attribute unsigned long  loadType;

  /*
   * returns true if the docshell is being destroyed, false otherwise
   */
  boolean isBeingDestroyed();

  /*
   * Returns true if the docshell is currently executing the onLoad Handler
   */
  readonly attribute boolean isExecutingOnLoadHandler;

  attribute nsILayoutHistoryState layoutHistoryState;

  readonly attribute boolean shouldSaveLayoutState;

  /**
   * The SecureBrowserUI object for this docshell.  This is set by XUL
   * <browser> or nsWebBrowser for their root docshell.
   */
  attribute nsISecureBrowserUI securityUI;

  /**
   * Cancel the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively. The meta-refresh timers can be
   * restarted using resumeRefreshURIs().  If the timers are already suspended,
   * this has no effect.
   */
  void suspendRefreshURIs();

  /**
   * Restart the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively.  If the timers are already
   * running, this has no effect.
   */
  void resumeRefreshURIs();

  /**
   * Begin firing WebProgressListener notifications for restoring a page
   * presentation. |viewer| is the content viewer whose document we are
   * starting to load.  If null, it defaults to the docshell's current content
   * viewer, creating one if necessary.  |top| should be true for the toplevel
   * docshell that is being restored; it will be set to false when this method
   * is called for child docshells.  This method will post an event to
   * complete the simulated load after returning to the event loop.
   */
  void beginRestore(in nsIContentViewer viewer, in boolean top);

  /**
   * Finish firing WebProgressListener notifications and DOM events for
   * restoring a page presentation.  This should only be called via
   * beginRestore().
   */
  void finishRestore();

  /* Track whether we're currently restoring a document presentation. */
  readonly attribute boolean restoringDocument;

  /* attribute to access whether error pages are enabled */
  attribute boolean useErrorPages;

  /**
   * Keeps track of the previous SHTransaction index and the current
   * SHTransaction index at the time that the doc shell begins to load.
   * Used for ContentViewer eviction.
   */
  readonly attribute long previousTransIndex;
  readonly attribute long loadedTransIndex;

  /**
   * Notification that entries have been removed from the beginning of a
   * nsSHistory which has this as its rootDocShell.
   *
   * @param numEntries - The number of entries removed
   */
  void historyPurged(in long numEntries);

  /*
   * Retrieves the WebApps session storage object for the supplied domain.
   * If it doesn't already exist, a new one will be created.
   *
   * @param uri the uri of the storage object to retrieve
   * @param documentURI new storage will be created with reference to this
   *                    document.documentURI that will appear in storage event
   */
  nsIDOMStorage getSessionStorageForURI(in nsIURI uri,
                                        in DOMString documentURI);

  /*
   * Retrieves the WebApps session storage object for the supplied principal.
   *
   * @param principal returns a storage for this principal
   * @param documentURI new storage will be created with reference to this
   *                    document.documentURI that will appear in storage event
   * @param create If true and a session storage object doesn't
   *               already exist, a new one will be created.
   */
  nsIDOMStorage getSessionStorageForPrincipal(in nsIPrincipal principal,
                                              in DOMString documentURI,
                                              in boolean create);

  /*
   * Add a WebApps session storage object to the docshell.
   *
   * @param principal the principal the storage object is associated with
   * @param storage the storage object to add
   */
  void addSessionStorage(in nsIPrincipal principal, in nsIDOMStorage storage);

  /**
   * Gets the channel for the currently loaded document, if any. 
   * For a new document load, this will be the channel of the previous document
   * until after OnLocationChange fires.
   */
  readonly attribute nsIChannel currentDocumentChannel;

  /**
   * Set the offset of this child in its container.
   */
  [noscript] void setChildOffset(in unsigned long offset);

  /**
   * Find out whether the docshell is currently in the middle of a page
   * transition. This is set just before the pagehide/unload events fire.
   */
  readonly attribute boolean isInUnload;

  /**
   * Find out if the currently loaded document came from a suspicious channel
   * (such as a JAR channel where the server-returned content type isn't a
   * known JAR type).
   */
  readonly attribute boolean channelIsUnsafe;

  /**
   * Disconnects this docshell's editor from its window, and stores the
   * editor data in the open document's session history entry.  This
   * should be called only during page transitions.
   */
  [noscript, notxpcom] void DetachEditorFromWindow();

  /**
   * If true, this browser is not visible in the traditional sense, but
   * is actively being rendered to the screen (ex. painted on a canvas)
   * and should be treated accordingly.
   **/
  attribute boolean isOffScreenBrowser;    

  /**
   * If the current content viewer isn't initialized for print preview,
   * it is replaced with one which is and to which an about:blank document
   * is loaded.
   */
  readonly attribute nsIWebBrowserPrint printPreview;

  /**
   * Whether this docshell can execute scripts based on its hierarchy.
   * The rule of thumb here is that we disable js if this docshell or any
   * of its parents disallow scripting, unless the only reason for js being
   * disabled in this docshell is a parent docshell having a document that
   * is in design mode.  In that case, we explicitly allow scripting on the
   * current docshell.
   */
  readonly attribute boolean canExecuteScripts;

  /**
   * Sets whether a docshell is active. An active docshell is one that is
   * visible, and thus is not a good candidate for certain optimizations
   * like image frame discarding. Docshells are active unless told otherwise.
   */
  attribute boolean isActive;

  /**
   * The ID of the docshell in the session history.
   */
  readonly attribute unsigned long long historyID;

  /**
   * Sets whether a docshell is an app tab. An app tab docshell may behave
   * differently than a non-app tab docshell in some cases, such as when
   * handling link clicks. Docshells are not app tabs unless told otherwise.
   */
  attribute boolean isAppTab;

  /**
   * Create a new about:blank document and content viewer.
   * @param aPrincipal the principal to use for the new document.
   */
  void createAboutBlankContentViewer(in nsIPrincipal aPrincipal);
};


/**
 * This interface provides a way to stream data to the web browser. This allows
 * loading of data from sources which can not be accessed using URIs and
 * nsIWebNavigation.
 */
[scriptable, uuid(86d02f0e-219b-4cfc-9c88-bd98d2cce0b8)]
interface nsIWebBrowserStream : nsISupports
{
  /**
   * Prepare to load a stream of data. When this function returns successfully,
   * it must be paired by a call to closeStream.
   *
   * @param aBaseURI
   *        The base URI of the data. Must not be null. Relative
   *        URIs will be resolved relative to this URI.
   * @param aContentType
   *        ASCII string giving the content type of the data. If rendering
   *        content of this type is not supported, this method fails.
   *        This string may include a charset declaration, for example:
   *        text/html;charset=ISO-8859-1
   *
   * @throw NS_ERROR_NOT_AVAILABLE
   *        The requested content type is not supported.
   * @throw NS_ERROR_IN_PROGRESS
   *        openStream was called twice without an intermediate closeStream.
   */
  void openStream(in nsIURI aBaseURI, in ACString aContentType);

  /**
   * Append data to this stream.
   * @param aData The data to append
   * @param aLen  Length of the data to append.
   *
   * @note To append more than 4 GB of data, call this method multiple times.
   */
  void appendToStream([const, array, size_is(aLen)] in octet aData,
                      in unsigned long aLen);

  /**
   * Notifies the browser that all the data has been appended. This may notify
   * the user that the browser is "done loading" in some form.
   *
   * @throw NS_ERROR_UNEXPECTED
   *        This method was called without a preceding openStream.
   */
  void closeStream();
};


[scriptable, uuid(ea604e90-40ba-11d5-90bb-0010a4e73d9a)]
interface nsIProgrammingLanguage : nsISupports
{
    /**
     * Identifiers for programming languages.
     */
    const PRUint32 UNKNOWN     = 0;
    const PRUint32 CPLUSPLUS   = 1;
    const PRUint32 JAVASCRIPT  = 2;
    const PRUint32 PYTHON      = 3;
    const PRUint32 PERL        = 4;
    const PRUint32 JAVA        = 5;
    const PRUint32 ZX81_BASIC  = 6;  // it could happen :)
    const PRUint32 JAVASCRIPT2 = 7;
    const PRUint32 RUBY =        8;
    const PRUint32 PHP =         9;
    const PRUint32 TCL =         10;
    // This list can grow indefinitely. Just don't ever change an existing item.
    const PRUint32 MAX         = 10; // keep this as the largest index.
    
};
